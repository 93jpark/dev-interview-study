## 좋은코드란 무엇인가?

`좋은 코드`에 대한 정의는 개발자가 사용하는 언어, 프레임워크, 필드 등에 따라 달라질 수 있다. 다양한 필드의 많은 개발자들이 이야기하는 `좋은 코드`에는 공통점이 존재하며, 출판된지 10년이 넘은 *클린코드(로버트 마틴 저)*에서도 좋은 코드에 대해 이야기한다. 주관적인 이 질문에 대해 시니어 개발자들의 답변과 관련 글들을 정리해서 `좋은 코드`가 무엇인지 알아보도록 하자.


### 악취나는 코드, 이를 위한 코드 규범
개발자는 직관적으로 코드에서 찝찝함을 느낀다. 이를 나쁜 냄새가 나는 코드라고 *클린 코드*에서 이야기한다. 직관이라는 것은 말로 설명하기 어려운 주관적 영역에 속한다. 지금까지 활동해 온 선배 개발자들은 이러한 직관들에 이름을 붙이고 이에 대해 약속(Convetion)을 구축하고 우선순위를 정하며 하나의 합의를 도출해냈다. 대표적인 예시로, *Camel Case*, *pascal case*, *snake case*등과 같은 `이름 규약(name convention)`이 발생했고 지금 우리는 이러한 규범에 따라 코드를 작성하고 있다.

이러한 관습, 약속, 또는 표준들은 무엇을 위해 존재할까? 바로 코드를 통해 다른 개발자와 원활하게 소통(communication)하기 위함이다. 어떤 코드가 좋은 코드인가에 대한 첫 대답은 '소통'에 문제가 없는, 이에 도움이 될 수 있는 코드를 좋은코드라고 할 수 있다.

아래에서는 *클린 코드*에서 이야기하는 좋은 코드의 특징들을 하나씩 짚어 볼 예정이다.


### 가독성 Reability
책에서는 *처음 보는 사람*이 문서 없이 코드만으로 프로그램의 동작을 직관적으로 파악할 수 있도록 하는 것을 목표로 한다. 여기서 *처음 보는 사람*은 함께 개발하는 동료, 유지보수를 하게 될 미래의 후임, 사용자, 또는 3달 뒤의 자기자신을 말한다.

>We don't read code, we decode it. - *Peter Seibel*
>우리는 코드를 읽는 것이 아니라 해석한다.

코드에서 가독성이 확보하게 되면 코드를 해석하는데에 드는 비용이 줄어들게 된다. 프로그램의 이해를 위해 코드를 반복해서 읽는 것은 엄청난 인력 낭비에 속한다. 코드를 직접 짜는 업무는 코드를 읽는 행위의 10%에 지나지 않는다. 좋은 코드를 통해 코드를 읽는 과정을 효율적으로 한다면 업무 진행에 엄청난 도움을 줄 수 있다는 말이다.

그렇다면 여기서 말하는 가독성은 무엇을 말하는 것인가?

#### 표현적 가독성 Legibility
> 눈에 잘 들어오는 코드, 읽기 편한 코드

`Coding Convention`
표현적 가독성은 코드의 개별 요소를 얼마나 파악하기 쉬운지를 의미한다. 여기에는 언어별로 존재하는 `Coding Convention`을 언급할 수 있다. 자바에서는 Camel Case를 사용하며, SQL 또는 JavaScript에서는 Snake Case를 사용한다. 개발자는 여러 언어를 동시에 사용해서 개발할 경우, 이와 같은 네이밍 룰을 통해 직관적으로 어떤 언어를 통해 개발하고 있는지 파악할 수 있다.

```
    thisIsJava // Camel Case from Java
    this_is_for_JS // Snake Case from Java Script
```

이처럼 단순히 개발자 본인의 취향에 따라 코드를 짜는 것이 아닌 개발 커뮤니티에서 따르는 규약(Convention)을 따라서 개발하는 것이 좋다.

`Integrated Development Environment`
거의 모든 개발자는 IDE를 통해 코드를 작성한다. 이 IDE에서 얼마나 읽기 편한 환경을 구성하느냐에 따라 작업의 효율성에 영향을 미칠 수 있다. 보통 IDE formatter를 통해서 함께 일하는 동료들과 통일된 환경에서 작업하도록 한다.

다음은 *클린 코드*에서 이야기하는 좋은 IDE formatter이다.
- 최대 가로 길이를 화면 절반쯤에 맞춘다.
- 파일당 행은 500줄 미만으로 한다.
- 하나의 파일은 두괄식으로 작성한다.
- 변수는 사용하는 곳과 가까운 곳에 선언한다. 즉, 함수가 시작되는 초입에 몰아서 선언하지 않는다.

`Function`

>The first rule of functions is that they should be small.
>The second rule of functions is that they should be smaller than that

함수 또는 메소드는 한 가지의 기능에 대해서만 책임을 갖게 하는 것이 좋습니다. 이를 *단일 책임 원칙(SRP, Single Responsibility Principle)*이라고 한다. 위의 언급한 문장들처럼, 함수의 기능을 최소화하도록 하라고 말한다. 이는 기능을 최소단위로 함으로써 유지보수에 용이하기 때문입니다. 또한, 한 함수 또는 메소드가 길어지면 한 화면에서 코드를 읽을 수 없기 때문에 가독성이 떨어지게 됩니다. 책과 아티클에서는 함수 내부의 코드들을 그저 로직의 나열이 아닌 n-1단계의 추상화를 갖는 함수의 집합으로 만드라고 합니다. 

또, for/if/switch등의 들여 쓰기는 가능한 1회만 하며 들여쓰기가 중첩된다면 함수 호출로 대신하길 권장합니다.


`Comment`
주석은 프로그램에 직접적으로 영향을 미치지 않는 만큼 중요도가 낮은 부분이다. 하지만, 중요도가 낮은 만큼 개발 과정에서 등한시되기 쉬운 부분이다. 잘못된 코드에 대해서는 수정이 이루어질 수 있지만 잘못된 주석에 대한 수정은 보장하기 어렵다. 개발자가 가볍게 넘길 수 있기 때문이다. 그래서 *클린 코드*에서는 주석은 필요악이라고 이야기한다. 가능한 주석을 최소한으로 사용하라는 것이다.

좋은 코드는 주석 없이 코드 자체가 스스로를 설명(Self-Descriptive)할 수 있다. 외적인 맥락이나 비지니스 로직에서 제한사항 등과 같이 코드를 통해 설명할 수 없는 부분만 주석으로 설명하는 것을 권장한다.

```java
// tutorial comment
// iterate over the range 0 to 9
// invoke the foo function
// for each iteration
for(int i=0; i<10; i++) {
    foo(i);
}

// document why, not how : 여전히 안좋은 코드
// instantiate 10 thread to handle upcoming work load
for(int i=0; i<10; i++) {
    foo(i);
}

// self-demonstrative names : 좋은 코드
for(int taskId=0; taskId <10; taskId++) {
    instantiateThread(taskId);
}

// self-demonstrative names : 훨씬 나은 코드
for(int taskId=0; taskId <10; taskId++) {
    instantiateBotQueueConsumeThread(taskId);
}
```

하지만, 주석이 필요악임에도 불구하고 불변하는 진리는 이해할 수 없는 코드 보단 장황한 주석을 통해 이해를 돕는게 좋다.

#### Readability 
: 변수, 함수, 클래스 등이 어떤 역할을 갖고, 어떤 동작을 하며, 어떤 연관 관계를 맺는지 직관적으로 파악할 수 있는 코드

영어로 Read+Ability의 조합인 가독성(readability)는 코드가 이해하기 쉬운지 어려운지를 뜻한다. 맥락에 따라 자연스럽게 읽어진다면 readable하다고 할 수 있다.

`함수의 내려가기 규칙 stepdown rule`
앞서 언급한 함수의 내려가기 규칙은 기능적 가독성을 구성하는 가장 중요한 요소이다.

- 함수는 한가지 추상화 단계를 처리한다.
- n단계의 추상적인 함수는 n-1단계의 추상적인 함수로 구성된다.

*추상화*라는 단어가 낯설게 느껴진다면 문제 또는 과업(Task)로 치환할 수 있다. '식사를 한다'는 것이 추상적인 문제라면, '점심에 동료들과 덮밥을 먹는다'는 건 보다 구체적인 과업의 집합이다.

위의 예시를 활용하면, 내려가기 규칙은 함수를 작성할 때 '점식 식사를 한다'와 같은 추상화 단계가 섞이지 않도록 한다. 즉, 행위 또는 동작의 최소 단위를 함수로 표현하라는 것이다.
```Java
/* 식사 기능 명세
    - 식사를 한다.
    - 누가 먹나?
    - 무엇을 먹나?
    - 어디서 먹나?
 */
public void haveMeal(Company myCorp) {
    List<Developer> mealMembers = myCorp.getColleagues();
    Menu todayMenu = myCorp.selectMenu(mealMembers, LocalTime.now());
    Place restaruant = myCorp.selectRestaurant(todayMenu, mealMembers.size());
}

```



`의미 있는 이름`
변수 또는 함수, 파일 등의 이름을 짓는 것은 '소통'에 있어 매우 중요한 요소다. 짧고 불명확한 이름보다는 길고 명확한 이름이 좋다.

- 항상 이름 있는 상수(named constant)를 사용하며, 매직 넘버/스트링은 사용하지 않는다.
- -Info, -Data, tmp-와 같은 무의미한 접미사/접두사는 제거한다.
- 대명사, 축약, 생략은 알아보기 힘들다.
- 서로 무관한 함수에서 같은 이름을 사용해선 안된다.(구분 가능성))
- 서로 연관된 함쉥서 같은 대상을 다른 이름으로 불러선 안된다.(일관성)
- 타입 인코딩(-string, -int 같이 타입을 적어두는 것)은 지양한다.







>Reference
[네이버 클라우드 개발자(저 이동엽) 좋은 코드란 무엇일까, 클린코드 이야기](https://medium.com/naver-cloud-platform/네이버클라우드-개발자-스토리-좋은-코드란-무엇일까-클린코드-이야기-c7811f73a46b)
[Intent HQ - What Is Good Code?](https://intenthq.com/blog/it-audience/what-is-good-code-a-scientific-definition/)
[JBEE - 좋은코드란 무엇일까? 프론트 쪽 개발자에게 추천](https://jbee.io/etc/what-is-good-code/)