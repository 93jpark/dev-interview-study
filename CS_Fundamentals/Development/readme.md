# 개발상식


## :memo: Table of Contents

- [좋은코드란 무엇인가?](#좋은-코드란-무엇인가)
- [함수형 프로그래밍이란?](#함수형-프로그래밍이란)
    - [대표 함수형 프로그래밍](#대표적인-함수형-프로그래밍-특징)
    - [함수형 프로그래밍 장점](#함수형-프로그래밍-장점)
- [OOP](#oop)
    - [객체지향 프로그래밍이란?](#객체-지향-프로그래밍oop이란-무엇인가)
    - [OOP의 특징](#oop의-특징)
    - [객체지향 설계원칙](#객체-지향적-설계-원칙)
- [TDD](#tdd란)
    - [TDD와 장점](#tdd란-무엇이며-어떠한-장점이-있는가)
    - [TDD의 사용배경](#tdd를-왜-해야할까)
    - [TDD의 효과](#tdd의-효과)
    - [TDD의 단점](#tdd의-단점)
- [MVC패턴](#mvc-패턴)
    - [MVC패턴의 정의](#mvc-패턴이란-무엇인가)
    - [MVC패턴 사용배경](#왜-mvc패턴을-사용해야-할까)
- [RESTful API](#restful-api)
    - [API](#api)
    - [REST API 설계](#rest-api-설계하기)

<br>

---

<br>

## 좋은코드란 무엇인가?

`좋은 코드`에 대한 정의는 개발자가 사용하는 언어, 프레임워크, 필드 등에 따라 달라질 수 있다. 다양한 필드의 많은 개발자들이 이야기하는 `좋은 코드`에는 공통점이 존재하며, 출판된지 10년이 넘은 *클린코드(로버트 마틴 저)*에서도 좋은 코드에 대해 이야기한다. 주관적인 이 질문에 대해 시니어 개발자들의 답변과 관련 글들을 정리해서 `좋은 코드`가 무엇인지 알아보도록 하자.


### 악취나는 코드, 이를 위한 코드 규범
개발자는 직관적으로 코드에서 찝찝함을 느낀다. 이를 나쁜 냄새가 나는 코드라고 *클린 코드*에서 이야기한다. 직관이라는 것은 말로 설명하기 어려운 주관적 영역에 속한다. 지금까지 활동해 온 선배 개발자들은 이러한 직관들에 이름을 붙이고 이에 대해 약속(Convetion)을 구축하고 우선순위를 정하며 하나의 합의를 도출해냈다. 대표적인 예시로, *Camel Case*, *pascal case*, *snake case*등과 같은 `이름 규약(name convention)`이 발생했고 지금 우리는 이러한 규범에 따라 코드를 작성하고 있다.

이러한 관습, 약속, 또는 표준들은 무엇을 위해 존재할까? 바로 코드를 통해 다른 개발자와 원활하게 소통(communication)하기 위함이다. 어떤 코드가 좋은 코드인가에 대한 첫 대답은 '소통'에 문제가 없는, 이에 도움이 될 수 있는 코드를 좋은코드라고 할 수 있다.

아래에서는 *클린 코드*에서 이야기하는 좋은 코드의 특징들을 하나씩 짚어 볼 예정이다.


### 가독성 Reability
책에서는 *처음 보는 사람*이 문서 없이 코드만으로 프로그램의 동작을 직관적으로 파악할 수 있도록 하는 것을 목표로 한다. 여기서 *처음 보는 사람*은 함께 개발하는 동료, 유지보수를 하게 될 미래의 후임, 사용자, 또는 3달 뒤의 자기자신을 말한다.

>We don't read code, we decode it. - *Peter Seibel*
>우리는 코드를 읽는 것이 아니라 해석한다.

코드에서 가독성이 확보하게 되면 코드를 해석하는데에 드는 비용이 줄어들게 된다. 프로그램의 이해를 위해 코드를 반복해서 읽는 것은 엄청난 인력 낭비에 속한다. 코드를 직접 짜는 업무는 코드를 읽는 행위의 10%에 지나지 않는다. 좋은 코드를 통해 코드를 읽는 과정을 효율적으로 한다면 업무 진행에 엄청난 도움을 줄 수 있다는 말이다.

그렇다면 여기서 말하는 가독성은 무엇을 말하는 것인가?

#### 표현적 가독성 Legibility
> 눈에 잘 들어오는 코드, 읽기 편한 코드

`Coding Convention`
표현적 가독성은 코드의 개별 요소를 얼마나 파악하기 쉬운지를 의미한다. 여기에는 언어별로 존재하는 `Coding Convention`을 언급할 수 있다. 자바에서는 Camel Case를 사용하며, SQL 또는 JavaScript에서는 Snake Case를 사용한다. 개발자는 여러 언어를 동시에 사용해서 개발할 경우, 이와 같은 네이밍 룰을 통해 직관적으로 어떤 언어를 통해 개발하고 있는지 파악할 수 있다.

```
    thisIsJava // Camel Case from Java
    this_is_for_JS // Snake Case from Java Script
```

이처럼 단순히 개발자 본인의 취향에 따라 코드를 짜는 것이 아닌 개발 커뮤니티에서 따르는 규약(Convention)을 따라서 개발하는 것이 좋다.

`Integrated Development Environment`
거의 모든 개발자는 IDE를 통해 코드를 작성한다. 이 IDE에서 얼마나 읽기 편한 환경을 구성하느냐에 따라 작업의 효율성에 영향을 미칠 수 있다. 보통 IDE formatter를 통해서 함께 일하는 동료들과 통일된 환경에서 작업하도록 한다.

다음은 *클린 코드*에서 이야기하는 좋은 IDE formatter이다.
- 최대 가로 길이를 화면 절반쯤에 맞춘다.
- 파일당 행은 500줄 미만으로 한다.
- 하나의 파일은 두괄식으로 작성한다.
- 변수는 사용하는 곳과 가까운 곳에 선언한다. 즉, 함수가 시작되는 초입에 몰아서 선언하지 않는다.

`Function`

>The first rule of functions is that they should be small.
>The second rule of functions is that they should be smaller than that

함수 또는 메소드는 한 가지의 기능에 대해서만 책임을 갖게 하는 것이 좋습니다. 이를 *단일 책임 원칙(SRP, Single Responsibility Principle)*이라고 한다. 위의 언급한 문장들처럼, 함수의 기능을 최소화하도록 하라고 말한다. 이는 기능을 최소단위로 함으로써 유지보수에 용이하기 때문입니다. 또한, 한 함수 또는 메소드가 길어지면 한 화면에서 코드를 읽을 수 없기 때문에 가독성이 떨어지게 됩니다. 책과 아티클에서는 함수 내부의 코드들을 그저 로직의 나열이 아닌 n-1단계의 추상화를 갖는 함수의 집합으로 만드라고 합니다. 

또, for/if/switch등의 들여 쓰기는 가능한 1회만 하며 들여쓰기가 중첩된다면 함수 호출로 대신하길 권장합니다.


`Comment`
주석은 프로그램에 직접적으로 영향을 미치지 않는 만큼 중요도가 낮은 부분이다. 하지만, 중요도가 낮은 만큼 개발 과정에서 등한시되기 쉬운 부분이다. 잘못된 코드에 대해서는 수정이 이루어질 수 있지만 잘못된 주석에 대한 수정은 보장하기 어렵다. 개발자가 가볍게 넘길 수 있기 때문이다. 그래서 *클린 코드*에서는 주석은 필요악이라고 이야기한다. 가능한 주석을 최소한으로 사용하라는 것이다.

좋은 코드는 주석 없이 코드 자체가 스스로를 설명(Self-Descriptive)할 수 있다. 외적인 맥락이나 비지니스 로직에서 제한사항 등과 같이 코드를 통해 설명할 수 없는 부분만 주석으로 설명하는 것을 권장한다.

```java
// tutorial comment
// iterate over the range 0 to 9
// invoke the foo function
// for each iteration
for(int i=0; i<10; i++) {
    foo(i);
}

// document why, not how : 여전히 안좋은 코드
// instantiate 10 thread to handle upcoming work load
for(int i=0; i<10; i++) {
    foo(i);
}

// self-demonstrative names : 좋은 코드
for(int taskId=0; taskId <10; taskId++) {
    instantiateThread(taskId);
}

// self-demonstrative names : 훨씬 나은 코드
for(int taskId=0; taskId <10; taskId++) {
    instantiateBotQueueConsumeThread(taskId);
}
```

하지만, 주석이 필요악임에도 불구하고 불변하는 진리는 이해할 수 없는 코드 보단 장황한 주석을 통해 이해를 돕는게 좋다.

#### Readability 
: 변수, 함수, 클래스 등이 어떤 역할을 갖고, 어떤 동작을 하며, 어떤 연관 관계를 맺는지 직관적으로 파악할 수 있는 코드

영어로 Read+Ability의 조합인 가독성(readability)는 코드가 이해하기 쉬운지 어려운지를 뜻한다. 맥락에 따라 자연스럽게 읽어진다면 readable하다고 할 수 있다.

`함수의 내려가기 규칙 stepdown rule`
앞서 언급한 함수의 내려가기 규칙은 기능적 가독성을 구성하는 가장 중요한 요소이다.

- 함수는 한가지 추상화 단계를 처리한다.
- n단계의 추상적인 함수는 n-1단계의 추상적인 함수로 구성된다.

*추상화*라는 단어가 낯설게 느껴진다면 문제 또는 과업(Task)로 치환할 수 있다. '식사를 한다'는 것이 추상적인 문제라면, '점심에 동료들과 덮밥을 먹는다'는 건 보다 구체적인 과업의 집합이다.

위의 예시를 활용하면, 내려가기 규칙은 함수를 작성할 때 '점식 식사를 한다'와 같은 추상화 단계가 섞이지 않도록 한다. 즉, 행위 또는 동작의 최소 단위를 함수로 표현하라는 것이다.
```Java
/* 식사 기능 명세
    - 식사를 한다.
    - 누가 먹나?
    - 무엇을 먹나?
    - 어디서 먹나?
 */
public void haveMeal(Company myCorp) {
    List<Developer> mealMembers = myCorp.getColleagues();
    Menu todayMenu = myCorp.selectMenu(mealMembers, LocalTime.now());
    Place restaruant = myCorp.selectRestaurant(todayMenu, mealMembers.size());
}

```



`의미 있는 이름`
변수 또는 함수, 파일 등의 이름을 짓는 것은 '소통'에 있어 매우 중요한 요소다. 짧고 불명확한 이름보다는 길고 명확한 이름이 좋다.

- 항상 이름 있는 상수(named constant)를 사용하며, 매직 넘버/스트링은 사용하지 않는다.
- -Info, -Data, tmp-와 같은 무의미한 접미사/접두사는 제거한다.
- 대명사, 축약, 생략은 알아보기 힘들다.
- 서로 무관한 함수에서 같은 이름을 사용해선 안된다.(구분 가능성))
- 서로 연관된 함쉥서 같은 대상을 다른 이름으로 불러선 안된다.(일관성)
- 타입 인코딩(-string, -int 같이 타입을 적어두는 것)은 지양한다.


**추상화 단계에 따른 이름짓기**

함수는 내려갈수록(깊어질수록) 구체적이고 설명적인 이름을 갖도록 설계한다. 상위 함수가 모든 내부 동작을 설명할 수 없고, 한 개의 함수로 모든 것을 설명하려고 이름을 지으면 오히려 코드를 파악하기 힘들어진다.

역으로, 변수는 범위가 넓어질수록 구체적이어야 한다. 글로벌 변수의 경우 매우 구체적인 이름을 갖도록 한다.



`부수효과 Side Effect`
부수효과는 함수의 이름으로 파악할 수 없는 예측 불허의 행위들을 말한다. 


`YAGNI: You Aren't Gonna Need It`
YAGNI는 당장 사용되지 않는 코드를 미래에 사용할 것 같다고 생각해서 만드는 것을 말합니다. 이는 지양되어야 하며, 확장 가능성을 염두에 두는 것과 미리 확장하는 것은 다르다. 당장의 리소스 낭비로 이어지며, 코드를 읽는 사람에게 현재 유의미하다고 이해시키는 오해를 불러일으킬 수 있다.

`인자 Parameter`
인자는 보통 1~2개로 유지하며, 3개 이상이 되는 경우엔 구조체 등으로 묶어서 사용한다. 즉, 맥락을 주입하고 명확성을 보장한다.




>Reference
[네이버 클라우드 개발자(저 이동엽) 좋은 코드란 무엇일까, 클린코드 이야기](https://medium.com/naver-cloud-platform/네이버클라우드-개발자-스토리-좋은-코드란-무엇일까-클린코드-이야기-c7811f73a46b)
[Intent HQ - What Is Good Code?](https://intenthq.com/blog/it-audience/what-is-good-code-a-scientific-definition/)
[JBEE - 좋은코드란 무엇일까? 프론트 쪽 개발자에게 추천](https://jbee.io/etc/what-is-good-code/)

<br>

---

<br>

## 함수형 프로그래밍이란?

> 함수형 프로그래밍은 하나의 프로그래밍 패러다임으로 정의되는 일련의 코딩 접근 방식이며,
> 자료처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임을 의미합니다.

- ###### 명령형 프로그래밍 : 프로그래밍의 상태와 그것을 변경시키는 구문의 관점에서의 연산을 설명
  - 절차적 프로그래밍 : 프로시저(Procedure)를 이용해 순차적인 처리를 중요시 여기는 패러다임
- ###### 객체 지향 프로그래밍 : 객체들의 집합으로 프로그램의 상호작용을 표현
  - 선언형 프로그래밍 : 어떻게(How) 할 것인가 보다는 무엇(What)을 할 것인가를 표현
  - 함수형 프로그래밍 : 순수 함수(Pure Function)를 조합하고 프로그램을 만드는 방식

## 대표적인 함수형 프로그래밍 특징

### 1. 순수함수

- 동일한 입력에는 항상 같은 값을 받는 함수를 의미합니다
- 순수 함수는 입력 파라미터에만 의존합니다.
- 함수의 실행이 외부의 영향(Side Effect)을 끼치지 않습니다.

### 2. 불변성

- 함수형 프로그래밍에서의 데이터는 불변성을 유지해야 합니다.
- 원본 데이터 구조를 변경하지 않고 그 데이터의 복사본을 만들어서 그 일부를 변경하고, 변경한 복사본을 사용해 작업을 진행합니다.

### 3. 1급 객체와 고차함수

- 함수형 프로그래밍은 일급 객체 함수에 의존한다
- 일급 객체란?
  - 변수나 데이터 구조안에 담을 수 있습니다.
  - 파라미터로 전달 할 수 있습니다.
  - 반환값(return value)으로 사용할 수 있습니다.
  - 할당에 사용된 이름과 관계없이 고유한 구별이 가능합니다.
  - 동적으로 프로퍼티 할당이 가능합니다.

### 함수형 프로그래밍 장점

- 프로그램의 동작을 예측하기 쉽습니다.
- 더 나은 모듈화와 짧은 코드를 제공합니다 -> 가독성이 높은 코드를 작성하기 쉽습니다.
- 개발 생산성을 높일 수 있습니다.
- 유지보수에 좀더 수월합니다.

>Reference
>https://velog.io/@teo/functional-programming

---

## OOP

### 객체 지향 프로그래밍(OOP)이란 무엇인가?

<strong>`Object Oriented Programmig`</strong>의 약자로, 객체(object)란 말 그대로 대상을 나타내는 단어 이며, <strong>`OOP`</strong>란 객체의 관점에서 프로그래밍 하는 것을 의미한다.
컴퓨터가 사고하는대로 프로그래밍하는 이전의 프로그래밍 패러다임에서 인간 중심적으로 프로그래밍하는 기법 중 하나로, 현실 세계의 사물들을 하나의 객체로 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것이다. 이 것을 추상화라 한다.

### OOP의 특징

#### 1. 추상화

- 목적과 관련이 없는 부분을 제외해서 필요한 부분만을 표현하기 위한 개념
- 객체의 공통된 속성들 중 필요한 부분을 포착해서 클래스로 정의하는 설계 기법
  > 예를들어 등고선 지도를 그릴 때, 목적에 맞지 않는 부분을 제외하고 필요한 부분(지형의 높 낮이)만 표현하는데,
  > 이를 객체와 클래스의 관점에서 살펴보면 객체들은 실제 그 모습이지만, 클래스에는 객체들의 특징들이 들어있어야 한다고 정의하는 추상화된 개념이다.

<br>

#### 2. 캡슐화

- 외부에 노출할 필요가 없는 정보들을 은닉 (정보은닉)
  > TV 리모콘을 사용하는데 리모콘의 내부회로를 알 필요가 없듯 사용자 입장에서는 리모콘의 조작기능만 알면 되는 것 처럼 캡슐화를 하면 불필요한 정보를 감출 수 있기 때문에 정보은닉을 할 수 있다는 특징이 있다는 것이지 캡슐화가 곧 정보은닉을 얘기하는 건 아니다.
- 정보 은닉화를 통해 높은 응집도, 낮은 결합도를 유지할 수 있도록 설계하는 것
  > 한 곳에서 변화가 일어나도 다른 곳에 미치는 이펙트를 최소화 시키는 것을 의미한다.
  > 즉, 객체 내부의 어떤 동작에 대한 구현이 어떻게 되어있는지 감추는 것이다.
  > 외부에서 접근할 필요 없는 것들은 접근 지정자를 `private`로 두어 접근에 제한을 두는 것이다. 외부 객체는 객체 내부의 구조를 모르게 하고, 해당 객체가 노출해서 제공하는 필드와 메소드만 이용할 수 있도록 하여 의도하지 않는 동작 오류를 방지하고 유지보수 효율을 높일 수 있다.

<br>

#### 3. 상속

- 상속 관계에 있는 두 클래스에 대해 부모 클래스가 자손에게 속성을 물려주는 것.
  부모 클래스의 접근 제어가 private이나 default로 설정된 멤버는 자식 클래스에서 상속받지만 접근할 수는 없다.
- 코드 재사용이 목적

<br>

#### 4. 다형성

- 같은 형태지만 다른 기능을 하는 것
  > 예를 들어 고양이 클래스와 사자 클래스가 있는데, 고양이 클래스에는 "울음"이라는 속성이 정의되어 있고 사자가 고양이 클래스를 상속 받아 사자 클래스에도 "울음"이라는 속성이 자동으로 추가된다. 이를 앞서 상속이라 하는데, 고양이와 사자의 울음소리는 다르기 때문에 같은 속성을 상속받았지만 사자는 고양이와 울음 소리가 다르므로 "울음" 이라는 속성을 **오버라이딩**해서 사자 울음소리에 맞게 재정의 할 수 있다. 이를 다형성이라 한다.

<br>

### 객체 지향적 설계 원칙

1. **SRP** (Single Responsibility Principle) : 단일 책임 원칙
   클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
2. **OCP** (Open-Closed Principle) : 개방-폐쇄 원칙
   확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
3. **LSP** (Liskov Substitution Principle) : 리스코프 치환 원칙
   상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
4. **ISP** (Interface Segregation Principle) : 인터페이스 분리 원칙
   인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
5. DIP(Dependency Inversion Principle) : 의존 역전 원칙
   고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

출처 https://victorydntmd.tistory.com/117

---

## TDD란?

### TDD란 무엇이며 어떠한 장점이 있는가?

TDD란 **Test Driven Development의 약자**로 '**테스트 주도 개발**'이라고 한다.
설계 이후 코드 개발 및 테스트케이스를 작성하는 기존의 개발 프로세스와는 다르게
테스트 케이스를 작성 한 후 실제 코드를 개발하여 리펙토링 하는 절차를 따른다.
이러한 이유로 TDD를 *Test First Development*라고 부른다.

TDD는 작가가 책을 쓰는 과정과 유사하다. 목차를 처음 구상하고 목차에 맞는 내용을 고쳐쓰기를 반복한다.

이 과정을 TDD에 비유하면 목차구성 => "테스트코드 작성", 초안작성 => "코드개발", 고쳐쓰기 => "코드수정"에 해당한다.

반복적인 검토와 고쳐쓰기를 통해 좋은 글이 완성되는 것처럼 소프트웨어도 반복적인 테스트와 수정을 통해 고품질의 소프트웨어를 만들 수 있다.

![]
(https://velog.velcdn.com/images/huunguk/post/f963b63a-e761-4dc6-bae0-6b6ceb283bad/image.png)

일반적인 개발 방식과 TDD의 가장 큰 차이는 **테스트 코드를 작성한 뒤에 실제 코드를 작성**한다는 점이다.
디자인(설계) 단계에서 프로그래밍 목적을 반드시 **미리 정의**해야만 하고,
또 무엇을 테스트해야 할지 **미리 정의(테스트 케이스 작성)**해야만 한다.

### TDD를 왜 해야할까?

불확실성이 높을 때 "피드백"과 "협력"이 중요하기 때문에 피드백과 협력이 자주 이루어진다면 더 좋은 효과가 나올 수 있다.

### 그럼 어떤 상황에서 해야할까?

1. 처음해보는 프로그램 주제

- 나에 대한 불확실성이 높은 경우

2. 고객의 요구조건이 바뀔 수 있는 프로젝트

- 외부적인 불확실성이 높은 경우

3. 개발하는 중 코드를 많이 바꿔야 된다고 생각하는 경우

4. 개발하고 나서 이 코드를 누가 유지보수할지 모르는 경우

- 외부적인 불확실성

**즉 ! 불확실성이 높을때 TDD를 하면 된다.**

_\*코딩을 여러번 해봤고, 결과가 어떻게 나올지 뻔하다면 TDD를 하지 않아도 된다. 또한 얻는 것이 적다면 하지 않아도 된다._

### TDD의 효과

1. 디버깅 시간을 단축

2. 코드가 내 손을 벗어나기 전 가장 빠르게 피드백을 받을 수 있다.
   (기능 단위로 테스트를 진행하기 떄문)
3. 작성한 코드가 가지는 불안정성을 개선하여 생산성을 높일 수 있다.
4. 재설계 시간을 단축
5. 추가 구현이 용이

### TDD의 단점

1. 코드량이 늘어난다 => 생산성의 저하 => 빠른 생산성이 요구되는 시점에서는 큰 걸림돌이 된다. (기존의 비즈니스 로직, 각종 코드 디자인 + 테스트 코드 작성)

2. 주객전도

- 실제 코드가 더 중심이 되어야 하는데 테스트를 위해 코드의 구조를 바꿔야하나 고민이 생긴다
- 발생할 수 있는 상황에 대한 코드를 작성하기 위해 배보다 배꼽이 더 커진다.

### Summary

다양한 사용자가 존재하며, 생각지도 못한 예외 케이스가 존재할 수 있다. 테스트를 반드시 해야 하는 부분에 있어서 테스트 코드를 작성하는데 여러 난관이 겪는다면? 모든 코드에 대해서 테스트 코드를 작성할 수 없으며 작성할 필요도 없다. 또한 테스트 코드를 작성한다고 해서 버그가 발생하지 않는 것도 아니다.

---

## MVC 패턴

### MVC 패턴이란 무엇인가?

디자인패턴 중 하나로 MVC(Model-View-Controller)는 **사용자 인터페이스, 데이트 및 논리 제어를 구현하는데 널리 사용되는 디자인 패턴**이다. 소프트웨어의 비즈니스 로직과 화면을 구분하는데 중점을 두고 있다.

![](https://velog.velcdn.com/images/huunguk/post/788aaaa4-f87e-470f-a7c4-cb58bb79541a/image.png)

User가 Controller를 조작하면 Controller는 Model를 통해서 데이터를 가져오고, 그 정보를 바탕으로 View를 시각적 표현을 제어하여 사용자에게 전달한다.

### Model

**애플리케이션의 정보, 데이터를 나타낸다.**
DB, 처음 정의하는 상수, 초기화값, 변수 등을 뜻하며 또한 이러한 데이터와 정보들의 가공을 책임지는 컴포넌트를 말한다.

#### Model의 규칙

1. 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 한다.
2. 뷰나 컨트롤러에 대해 어떤 정보인지 알지 말아야 한다.
3. 변경이 일어나면, 변경 통지에 대한 처리 방법을 구현해야 한다.

### View

input text, checkbox 등 사용자 인터페이스 요소를 나타낸다.
즉, 데이터 및 객체의 입력, 보여주는 출력을 담당한다.
**(데이터를 기반으로 사용자들이 볼 수 있는 화면)**

#### View의 규칙

1. 모델이 가지고 있는 정보를 따로 저장해서는 안된다.
2. 모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 한다.
3. 변경이 일어나면 변경통지에 대한 처리방법을 구현해야 한다.

### Controller

사용자가 접근한 URL에 따라 사용자의 요청사항을 파악 ->
그 요청에 맞는 데이터를 Model을 의뢰 ->
데이터를 View에 반영 -> 사용자에게 알려준다.

즉, **데이터와 사용자인터페이스 요소들을 잇는 다리 역할**을 한다.
사용자가 데이터를 클릭하고, 수정하는 것에 대한 **"이벤트"**들을 처리하는 부분이다.

#### Controller의 규칙

1. 모델이나 뷰에 대해 알고 있어야 한다.
2. 모델이나 뷰의 변경을 모니터링 해야한다.

### 왜 MVC패턴을 사용해야 할까?

사용자가 보는 **페이지, 데이터처리** 그리고 이 2가지를 중간에서 제어하는 **컨트롤**
이 3가지로 구성되는 하나의 애플리케이션을 만들면 각각 맡은바에만 집중을 할 수 있게 된다. (ex. 공장의 분업화)

서로 분리되어 각자의 역할에 집중할 수 있게끔해 애플리케이션을 만든다면
유지보수성, 애플리케이션 확장성, 유연성이 증가하고 중복코딩이라는 문제점 또한 사라진다.

> 유연성 : 클라이언트의 새로운 요구사항에 대한 최소한의 비용으로 대체

### MVC 패턴의 예시

- Google의 Angular JS
- PHP의 CODEIGNITER
- Python의 django
- Facebook의 React

### MVC의 기반을 둔 다른 디자인 패턴

- MVVM(Model View ViewModel)
- MVP(Model View Presenter)
- MVW(Model View Whatever)

### Summary

**Model** - 백그라운드에서 동작하는 비즈니스 로직(데이터) 처리

**View **- 정보를 화면으로 보여주는 역할

**Controller **- 사용자의 입력 처리와 흐름 제어 담당.
화면과 Model과 View를 연결시켜주는 역할

결국 **"어떻게 나눌 것인가"** 에 대한 해답 중 하나이다.

어떤 특정한 역할들에 대해 역할분담을 할 때 가이드라인을 제시하는 방법중 하나가 `MVC패턴`이다.

<br>
---
<br>

## RESTful API

### API
API란 프로그램들이 서로 소통하는 방법이다.<br>즉, 코드들이 서로 소통하기 위하여 만들어진 것이 API이다.

**API의 종류**
  - WEB API : 브라우저
  - 공공 API : 공공 데이터
<br><br>
## REST API와 RESTFUL
- **REST API**
  - Representational State Transfer 의 약자
  - 서버의 자원을 어떠한 방식으로 접근하도록 해야 구체적으로 명시한 것
  - 자원을 정의(HTTP URI)하고 자원에 대한 주소를 지정(HTTP Method)하는 방법론
  - URI는 자원을 표현하는 데에 집중하며, 행위에 대한 정의는 HTTP Method를 통해 하는 것
  - HTTP 프로토콜을 그대로 사용하여 웹/모바일 개발에서 서버/클라이언트가 통신하기에 적합  <br><br>

- **REST의 구성 요소**
  - 자원(Resource) : HTTP URI를 이용하여 표현
  - 행위(Verb): HTTP HTTP Method를 이용하여 표현
  - 표현(Representations): 자원에 대한 행위의 내용<br><br>

- **RESTFUL이란?**
  - REST의 형식을 따르는 시스템을 의미한다.<br><br>

### REST API 설계하기
사용하기 쉬운 API란 팀 멤버들과 유저가 쉽게 활용할 수 있도록 설계된 API를 의미한다.

좋은 API를 설계하는 방법에 대해 알아보자

API가 필요한 URL을 만들 때 삽입, 수정, 삭제 명령어를 다음과 같이 구성 할 수 있다.
```
[예시1]  

1) /createBook  
2) /seeBooks  
3) /getBook/HarryPotter  
4) /deleteBook/HarryPotter  
5) /updateBook/HarryPotter  
6) /getTopRatedBook
```
<br>
<예시1>의 URL은 여러개의 동사로 정의되었으며 명확한 패턴이 없다. 따라서 좋은 설계 방식이라고 할 수 없다.

이를 몇가지 과정을 거쳐 개선해보자  
<br><br>
**첫번째, URL에서 동사를 제거한다.**

```
1) /Book
2) /Books  
3) /Book/HarryPotter  
4) /Book/HarryPotter  
5) /Book/HarryPotter  
6) /TopRatedBook  
```
<예시1>에서 동사를 없애면 URL에는 명사만 존재한다.
이때 명사는 2가지 방식으로 분류한다.
 
1) Books와 같은 **복수형 명사**.
2) 책 제목인 HarryPotter. 이때 책 제목은 DB에서 **고유 식별자**(Unique identifier)가 된다.

1의 경우 명사가 단수형이므로 사용 할 수 없다.<br> 또한, 3-5가 같아지는 것을 알 수 있다. <br>데이터 삽입 ,추출, 삭제 역할을 하던 URL이 동사 제거 후
그 형태가 같아졌다.
<br><br>
**두번째, Http Method를 사용한다.**   

명사만 남은 URL에서 데이터를 삽입, 갱신, 삭제하기 위하여 Http Method와 결합한다.  

> Http Method: GET,POST,PUT,DELETE

적용하면 다음과 같다  
 
1) 복수형 명사와 결합
- 데이터 삽입  

    - GET/Books

2) 고유 명사와 결합

- 데이터 갱신
  - POST/Books/HarryPotter

- 데이터 삭제
  - DELETE/Books/HarryPotter

응용하면 위의 형식을 계속 확장해 나갈 수 있다. 만약, 책의 등장 인물을 알고 싶다면 **GET/Books/HarryPotter/character** 의 형식으로 요청 가능하다.
<br><br>

>Reference
REST란 - https://hckcksrl.medium.com/rest%EB%9E%80-c602c3324196
YOUTUBE - [5분만에 제대로 설계하는 ⭐️ REST API](https://www.youtube.com/watch?v=4DxHX95Lq2U)


---