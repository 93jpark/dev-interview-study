## Cookie 쿠키

`쿠키`는 웹 브라우저에 저장/전송되는 작은 텍스트 조각을 말하며, 사용자의 방문에 관한 정보를 저장한다.

### 쿠키의 구조

- 이름
- 값
- 속성(key-value형식)
  - 쿠키의 만료 기간
  - 도메인
  - 플래그(Secure, HttpOnly, etc)

### 쿠키의 설정

쿠키는 서버와의 통신 중 Response HTTP 헤더의 `Set-Cookie`를 통해 웹 브라우저(클라이언트)에 설정된다. 쿠키가 세팅된 브라우저는 이후에 해당 서버와 통신 시 쿠키를 전송할 지 여부가 결정된다.

- 세션 쿠키:
  Expires/Max-Age 속성이 존재하지 않는 영구히 존재가능한 쿠키이며, 브라우저가 닫히면 소멸된다.
- 세션 토큰:
  Expires속성을 포함하는 쿠키로, 해당 만료기간에 소멸된다.

<br>

---

<br>

## Session 세션

`세션`은 클라이언트가 웹 서버에 접속한 시점으로부터 클라이언트가 종료하여 연결이 소멸될 때까지 같은 사용자로부터 오는 요청을 하나의 상태로 저장하여 통신하는 기술을 말한다.

> 방문자가 웹 서버에 접속해 있는 상태에 대한 하나의 단위

### HTTP Session 메커니즘

1. 서버는 접근한 클라이언트에게 Response의 헤더의 Set-Cookie값으로 클라이언트 식별자인 Session-Id를 발행한다.
2. 이때 발행된 Session-Id는 클라이언트 사이드에는 쿠키의 형태로, 서버에는 세션 아이디 파일에 저장된다.
3. 이후 서버는 클라이언트 측의 요청에 Session-ID의 존재 여부와 ID를 통한 클라이언트를 구분하여 서비스를 제공한다.

### 쿠키/세션 차이점

|     구분     |                쿠키                |          세션          |
| :----------: | :--------------------------------: | :--------------------: |
|   저장위치   |             클라이언트             |          서버          |
| 라이프사이클 |            만료 시 삭제            |    브라우저 종료 시    |
|     보안     | 로컬에 존재함으로 탈취/변조의 위험 | 서버에 저장됨으로 안전 |
|     속도     |                빠름                |      비교적 느림       |

**세션**이 쿠키에 비해 보안에 강력하지만, 접속한 클라이언트의 수가 많아질수록 서버에 부하가 발생한다. **쿠키**는 세션에 비해 빠르지만, 다양한 정보를 포함하기때문에 세션(Session-Id)에 비해 데이터의 크기가 크다. 따라서 통신에 있어 부하가 발생할 수 있다.

<br>

---

<br>

## JWT

`JSON Web TOken(JWT)`은 JSON 형태로 된 토큰을 말하며 구성은 아래와 같다.

- header
- payload
- signature

```Java
Authorization: Bearer eyJHgCidkeidkcDIekdid9.dkjefiksdiewifksdlfkeid.iefjksdjfieiw3kf3fjid
```

위는 `Base64`로 인코딩된 토큰의 예시이다. 이를 디코딩하면 다음과 같은 형태로 나타나게 된다.

```JavaScript
{   // header
    "typ": "JWT",
    "alg": "HS512"
}.
{   // payload
    "sub":"456512356c21566d2156151de5",
	"iss":"demo app",
	"iat":1595733657,
	"exp":1595733657
}.
Nn39skdf3n9dsknf39fnkdwnf39fnsf93nifsdn9f3k3fewfi // signature

```

### JWT 토큰의 구성

#### Header

- typ: Type의 줄임말로 토큰의 타입을 의미한다.
- alg: Algorith의 줄임말로, 토큰의 서명을 발행하는데에 사용된 해시 알고리즘의 종류를 의미한다.

#### Payload

- sub: subject의 줄임말로, 토큰의 주인을 의미한다. 사용자의 이메일 등과 같은 유일한 식별자를 통해 토큰의 주인을 판별한다.
- iss: issuer의 줄임말로, 토큰을 발행한 주체를 말한다. 앱이 토큰을 발행했다면 {app 이름}이 될 것이다.
- iat: issued at의 줄임말로, 토큰이 발행된 날짜와 시간을 의미한다.
- exp: expiration의 줄임말로, 토큰이 만료되는 시간을 의미한다.

#### Signature

토큰을 발행한 주체(Issuer)가 발행한 서명으로서, 토큰의 유효성 검증에 사죵된다.

### JWT의 전자서명

JWT의 전자 서명은 {헤더}.{페이로드}와 시크릿 키를 이용해 해시 함수에 돌린 암호화한 결과 값이다. **시크릿 키**란 나만 알고 있는 문자열, 비밀번호 같은 것을 의미한다.

최초 로그인 시 서버는 사용자의 아이디/비밀번호를 서버에 저장된 아이디와 비밀번호에 비교해 인증한다. 만약 인증된 사용자인 경우, {헤더}.{페이로드}부분을 작성하고, 자신의 시크릿 키로 {헤더}.{페이로드}부분을 전자 서명한다. 전자 서명(해싱)의 결과로 나온 값을 {헤더}.{페이로드}.{서명}으로 이어 붙이고 Base64로 인코딩한 후 반환한다.

이 토큰으로 리소스 접근을 요청하면, 서버는 토큰을 Base64로 디코딩한다. 디코딩한 결과 JSON을 {헤더}.{페이로드}와 {서명}부분으로 나눈다. 서버는 {헤더}.{페이로드}와 자신이 갖고 있는 Secret으로 전자 서명을 만든 후 방금 만든 전자 서명을 HTTP 요청이 갖고 온 {서명}부분과 비교해 이 토큰의 유효성을 검사한다. 서버가 방금 시크릿키를 이용해 만든 전자 서명과 HTTP 요청의 {서명} 부분이 일치하면 토큰이 유효하다는 뜻이다.

{헤더}와 {페이로드}를 기반으로 {서명}을 생성하였음으로, 당연히 {헤더}나 {페이로드}가 변경됬다면 {서명}또한 일치할 수 없다. 따라서 인증서버에 토큰의 유효성을 확인하기 위해 통신을 하지 않아도 된다.

단, 토큰을 누군가 가져가면 계정의 리소스에 접근할 수 있게 됨으로 반드시 HTTPS통신을 해야만 한다.

> **Base64**: 8비트 이진 데이터를 문자 코드에 영향을 받지 않고 ASCII 문자들로 이루어진 일련의 문자열로 바꾸는 인코딩 방식(64진법)

---

## Javascript는 동기식 언어

JS는 한 번에 하나의 작업을 수행한다.

**한 작업이 실행되는 동안 다른 작업은 멈춘 상태를 유지하고 자신의 차례를 기다리는 것을 말한다.**
(마치 음식점에서 키오스크를 이용하여 한 사람씩 결제하는 방식과 유사)

이러한 동작을 **단일 스레드(싱글 스레드), 동기**라고 부른다.

### 예시

```
console.log("jin")
console.log("hyeonguk")
```

이렇게 콘솔을 두 개 입력하고, 출력 결과를 보면
![](https://velog.velcdn.com/images/huunguk/post/a0dea111-f3b6-447a-9342-df1d7deab51a/image.PNG) 순서대로 **"jin" "hyeonguk"** 가 찍히는 것을 볼 수 있다.

### 왜 그렇게 나오는거지?

자바스크립트에는 **Memory Heap**과 **Call Stack**이 있는데 이 두가지는
**자바스크립트의 엔진의 주요 구성 요소**이다.

![](https://velog.velcdn.com/images/huunguk/post/8d8f4dbc-4de3-4d60-9012-edef9c05254a/image.png)

### Memory Heap?

변수와 객체의 메모리 할당을 담당하는 곳!

#### Call Stack?

함수가 호출이 되면 쌓이는 곳! (대신 함수가 쌓이는 순서는 반대로 실행)
JS에서 함수를 호출하면 **Call stack**이라는 곳에 호출 순서대로 쌓인다
그리고 **Stack**은 맨 마지막에 호출된 함수가 맨 먼저 반환된다

이 구조를 **LIFO(List in Frist Out)** 이라고 부른다.

![](https://velog.velcdn.com/images/huunguk/post/0ecada3b-df4f-47e2-8a47-c6249646d600/image.png)

이렇게 순서대로 "hello"가 **호출되면서** Call Stack에 **쌓이고**, "hello"를 **반환하면서** Call stack에서 **사라진다**.

이러한 방식으로 계속 진행되기 때문에 **콘솔에 순서대로 찍히는것!**

---

### 비동기처리 방식이란?

**어떠한 요청을 보내면 그 요청이 끝날때까지 기다리는 것이 아닌
응답에 관계없이 바로 다음 동작이 실행되는 방식이다.**

자바스크립트는 싱글 스레드 프로그래밍 언어이기 때문에 한 번에 한 가지 일만 할 수 있다.
즉, **비동기 처리가 필수적.**

### 비동기처리가 왜 필요한데?

예를들어 웹 페이지 로딩되거나, 어떠한 동작(Event)가 하나당 30초 이상이 걸린다고 생각을 하면
이 웹 페이지는 동작이 끝날 때까지 **화면에 나타나지 않거나, 다음 동작을 수행하는데 지장을 주게 된다.**

또한 **사용자들은 느리고, 응답이 없는 웹 사이트를 좋아하지 않는다!!**

그렇기 때문에 JS에서 웹 사이트가 동작할 때는, 비동기적으로 동작할 수 있어야 한다.

#### 동기적, 비동기적의 차이를 그림으로 설명!

![](https://velog.velcdn.com/images/huunguk/post/0ff017b0-bac6-411a-acf3-e08e11459566/image.png)

### 그런데 브라우저 위에서 JS가 어떻게 화면을 전환하며 HTTP 요청이나 여러 이벤트를 동시에 동작할 수 있는가?

이유는 바로 **JS의 실행 환경(Runtime)과 관련**이 있다.

브라우저에서는 JS 엔진 만으로 동작을 하지 않는데,
**브라우저에서의 JS 실행 환경에서는** JS 엔진 자체가 제공하지 않는 일부 기능인
**DOM 조작, AJAX와 같은 비동기 처리를 위한 Web API를 제공!!**

또한 이를 제어하기 위한 **이벤트 루프, 이벤트 큐(Callback Queue / task Queue)가 존재한다**

#### 이벤트 루프란?

Call Stack과 Task Queue를 주시하는 **작은 파트**를 말한다.
Stack이 비어있으면 task queue의 **첫 번째 call back부터 stack에 쌓아 효과적으로 실행**할 수 있게 해준다!

## 동기 / 비동기 동작 원리 요약

### 동기 동작 원리

1. 코드가 실행되면 순서대로 Call Stack에 함수가 쌓인다. (Push)

2. 쌓인 **반대 순서**로 함수가 실행! (LIFO)
3. 실행이 된 함수는 Call Stack에서 제거된다 (POP)

### 비동기 동작 원리

1. Call Stack에서 비동기 함수가 호출 시 **Stack에 먼저 쌓였다가
   Web API로 이동한 후** 해당 **함수가 등록**이 되고, **Call Stack에서 사라짐!**

2. Web API에서 비동기 함수의 이벤트가 발생 시, 해당 콜백 함수는 Callback Queue에 push(이동) 된다.
3. Call Stack이 비어있는지 이벤트 루프가 확인을 하는데 **비어있으면**, Call Stack에 Callback Queue에 있는 **콜백 함수를 넘겨준다.**(push)
4. Call satck에 들어온 함수는 실행이 되고, 실행이 끝나면 Call Stack에서 사라진다.

## 결론

JS는 **싱글 스레드인 동기적인 언어**이며,
JS는 브라우저 위에서 **별도의 API를 통해 비동기 처리를 한다**

> _**참고자료**_
> _자바스크립트 - 동기? 비동기 ? : https://ljtaek2.tistory.com/142
> 자바스크립트의 동작 원리 : https://ljtaek2.tistory.com/129?category=897337
> _

---
