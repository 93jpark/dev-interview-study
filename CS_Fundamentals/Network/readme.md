# Network

## :memo: Table of Contents

- [API](#api란)
  - [API 접근방식](#api의-접근-방식)
  - [API 장점](#api의-장점)
- [HTTP](#http)
  - [프로토콜](#프로토콜protocol)
  - [TCP & UDP](#tcptransmission-control-protocol-udpuser-datagram-protocol)
  - [HTTP 프로토콜의 문제점](#http-프로토콜의-문제점)
- [HTTPs](#https)
- [TCP & UDP](#tcp와-udp)
  - [전송계층](#전송-계층transport-layer)
  - [특징](#특징)
  - [UDP](#udp)
- [HTTP 동작과정, HTTP method, 상태코드](#http-동작과정과-http-method-상태코드)
  - [웹 동작과정](#웹-동작과정)
  - [HTTP method](#http-method)
  - [HTTP 상태코드](#http-상태코드)
- [HTTP와 Method](#http)
  - [GET](#get)
  - [POST](#post)
  - [GET/POST의 차이](#get과-post의-차이)

<br>

---

<br>

## API란?

> 컴퓨터나 컴퓨터 프로그램 사이의 연결이며, 일종의 소프트웨어 인터페이스이다.
> 프로그래머가 사용할 수 있는 도구나 서비스의 역할을 한다.

![API](https://user-images.githubusercontent.com/80400157/200486615-28d7af0f-0a14-4178-9fab-e10d6dcf2e79.jpg)

- 어느 한쪽에서 요청을 보내면 요청 받는 쪽에서는 데이터(HTML, XML, JSON)를 응답으로 보내줍니다.
- EX) 클라이언트가 요청(Reuqest)-> 서버/DB에서 응답(Response)하며 데이터(JSON) 전달

---

### API의 접근 방식

- Private API :
  - 다른 3자에게 공개하지 않으며 조직 내부 개발자에게 제공합니다.
  - 백엔드 데이터 및 애플리케이션 기능 일부를 여는 인터페이스 입니다.
  - 기업이나 연구 단체 내부에서 사용합니다.
- Partner API :
  - 조직외부에서 특정 허가된 사람들도 사용할수있는 API 입니다.
  - 비지니스 관계, 파트너 회사간 소프트 웨어 통합 할때 사용합니다.
- Public API :
  - 누구나 가져다 사용할 수 있는 공개된 API입니다.
  - 사용자에게 프로그래밍적 권한을 제공해 줍니다.

---

### API의 장점

- 데이터 접속의 표준화와 편의성
  - API는 모든 접속을 표주화 하기 때문에 누구나 손쉽게 동일한 엑세스를 할수있습니다.
- 자동화와 확장성
  - API를 통해 사람이 직접 조작하지 않아도 자동으로 데이터 생성하고 처리하여 줍니다.
  - 그리하여 워크플로우가 간소화 되고 애플리케이션 확장이 다소 용이합니다.
- 적용력
  - API는 변화, 예측 에도 도움이 됩니다
  - API를 통해 데이터를 수집하고 전달하는 데 있어 유연한 서비스 환경을 구축할수 있습니다

> Reference
> https://www.hanl.tech/blog/api%EB%9E%80-api%EC%9D%98-%EC%A0%95%EC%9D%98%EC%99%80-%EC%A2%85%EB%A5%98-%EC%9E%A5%EB%8B%A8%EC%A0%90/
> https://ittrue.tistory.com/31

---

## HTTP란?

(HyperText Transfer Protocol)

- 서로 다른 시스템들 사이에서 통신을 주고받게 해주는 가장 기초적인 프로토콜.
- 웹 서핑을 할 때 서버에서 자신의 브라우저로 데이터를 전송해 주는 용도로 가장 많이 사용된다. 인터넷 초기에 모든 웹 사이트에서 기본적으로 사용되었던 프로토콜이기도 하다.
- 주로 **TCP**를 사용하고 **HTTP/3** 부터는 **UDP**를 사용하며, 80번 포트를 사용한다.

>

#### 프로토콜(protocol)

컴퓨터 내부에서, 또는 컴퓨터 사이에서 데이터의 교환 방식을 정의하는 규칙 체계이다.
기기 간 통신은 교환되는 데이터의 형식에 대해 상호 합의를 요구한다. 이런 형식을 정의하는 규칙의 집합.

>

#### TCP(Transmission Control Protocol), UDP(User Datagram Protocol)

- TCP : 전송을 제어하는 프로토콜 (규약). 인터넷 상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
- UDP : 데이터를 데이터그램 단위로 처리하는 프로토콜

### HTTP 프로토콜의 문제점

서버에서부터 브라우저로 전송되는 정보가 암호화되지 않는다.
이 말은 즉, 데이터가 쉽게 도난당할 수 있다는 것이다.

- HTTP는 평문 통신이기 때문에 도청이 가능하다.
- 통신 상대를 확인하지 않기 때문에 위장이 가능하다.
- 완전성을 증명할 수 없기 때문에 변조가 가능하다.
- TCP/IP는 도청 가능한 네트워크이다.
- TCP/IP 구조의 통신은 전부 통신 경로 상에서 엿볼 수 있다. 패킷을 수집하는 것만으로 도청할 수 있다.

## HTTPS

(HyperText Protocol over Secure Socket Layer)

- http의 보안이 강화된 버전
- 통신의 인증과 암호화를 위해 넷스케이프 커뮤니케이션즈 코퍼레이션이 개발했으며, 전자상거래에 널리 쓰임
- 기존 http레이어에서 SSL(보안 소켓 계층) 프로토콜을 얹어 평문 데이터를 암호화한다.
- http와 가장 커다란 차이점은 바로 SSL 인증서이다.
  SSL은 서버와 브라우저 사이에 안전하게 암호화된 연결을 만들 수 있게 도와주고 서버 브라우저가 민감한 정보를 주고받을 때 이것이 도난당하는 것을 막아준다.
  쉽게 말해서 SSL인증서는 사용자가 사이트에 제공하는 정보를 암호화하고, 이렇게 전송된 데이터는 중간에서 누군가 훔쳐 낸다고 해도 데이터가 암호화되어 있기 때문에 해독할 수 없다.
- TCP/IP 443포트를 사용한다.
- 민감한 트래픽 (ex. 인증, 전자상거래)에 이용
- 검색 우선순위 (SEO: Search Engine Optimization)을 통해 https를 상위 노출 시켜줌

#### 고려해야하는 부분

- 암호화/ 복호화의 과정이 필요하기 때문에 http보다 속도가 느림(오늘날에는 거의 차이를 못느낌)
- 인증서를 발급하고 유지하기 위한 추가 비용 발생

---

## TCP와 UDP

- 네트워크의 전송계층에서 사용하는 프로토콜
- 데이터 전달을 위하여 사용하는 프로토콜<br><br>

#### 전송 계층(Transport Layer)

![image](https://user-images.githubusercontent.com/43839951/200315518-de8f061d-68de-41c5-9559-6ca2c4f5f108.png)

- OSI 7 계층 중 Layer 4 계층에 해당
- 송신자와 수신자를 연결하는 통신 서비스 제공
- 연결 지향 데이터 스트림 지원, 신뢰성, 흐름 제어를 제공<br><br>

#### TCP

- 전송 제어 프로토콜 (Transmission Control Protocol)의 약자

### 특징

- 연결 지향 프로토콜
- 가상회선 패킷 교환 방식을 사용
- 데이터의 전송 순서를 보장 (데이터의 순서 유지를 위해 각 바이트마다 번호를 부여)
- 신뢰성있는 데이터 전송(ACK 이용) => 데이터를 확실히 주고받을 때 사용
- 서버와 클라이언트는 1:1 연결된다 => 논리적 경로를 지정한 후 고정 경로로 통신
- Streaming 서비스에 불리하다(손실된 경우 재전송 요청을 하므로)
- ex. 웹/메일/파일 공유

> **연결 지향 프로토콜이란?**<br>
> 클라이언트와 서버가 연결된 상태에서 데이터를 주고받는 프로토콜

<br><br>

## UDP

- 사용자 데이터그램 통신 규약 (User Datagram Protocol: UDP)
- 안전하게 보호되어야 할 필요가 없는 실시간 응용 프로그램에서 흔히 이용

> 데이터그램: 독립적인 관계를 지니는 패킷

### 특징

- 비연결 지향 프로토콜
- 신뢰성 없는 데이터 전송(도착 결과 확인 과정이 없어 데이터 전송 중 손실 가능성이 있음)
- 패킷관리가 필요
- 시간 동기가 필요한 **실시간 스트리밍 서비스** 등에서 사용
- 서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다

> **비연결 지향 프로토콜이란?**<br>
> 데이터를 주고받을 때 연결 절차를 거치지 않고 발신자가 일방적으로 데이터를 발신하는 방식

<br><br>

### 비교

#### 공통점

- 포트 번호를 이용하여 주소를 지정
- 데이터 오류 검사를 위한 체크섬 존재

> 체크섬: 데이터를 송신하는 중에 발생할 수 있는 오류를 검출하기 위한 값

#### 차이점

![image](https://user-images.githubusercontent.com/43839951/200473184-e62b54b4-d6ab-44a4-a7a2-c4a10edac86a.png)

> **흐름제어와 혼잡제어**<br>
>
> **흐름제어**: 데이터를 송신하는 곳과 수신하는 곳의 **데이터 처리 속도를 조절**하여 **수신자의 버퍼 오버플로우를 방지**하는 것
>
> **혼잡제어**: 네트워크 내의 **패킷 수**가 넘치게 증가하지 않도록 방지하는 것

<br><br>

#### 면접 대비 질문

1. Window size의 역할?
2. TCP가 UDP에 비해 느린 이유?
   <br><br>

Reference>
[[CS전공지식면접] TCP / IP 4계층과 OSI 7계층 모델|작성자 큰돌](https://blog.naver.com/jhc9639/222713398150)<br><br>
[[Network] TCP / UDP의 개념과 특징, 차이점](https://coding-factory.tistory.com/614)<br><br>
[이해하면 인생이 바뀌는 TCP 송/수신 원리](https://www.youtube.com/watch?v=K9L9YZhEjC0&list=PLXvgR_grOs1BFH-TuqFsfHqbh-gpMbFoy&index=25)

---

## HTTP 동작과정과 HTTP method, 상태코드

`HTTP`는 HTML 문서와 같은 자원을 가져오기 위해 사용되는 통신규약이다. 웹 브라우저(클라이언트)와 서버 사이의 HTTP 통신을 통해 사용자는 웹 문서에 접근/이용할 수 있다. 서버 간에 데이터를 주고 받을 때도 대부분 HTTP를 사용한다.

클라이언트와 서버는 개별적인 메세지(데이터 스트림)를 주고받으며 통신한다. 웹 브라우저(클라이언트)가 보내는 메세지를 `요청(request)`라고 하며, 이에 반응하여 서버가 전송하는 메세지를 `응답(response)`라고 한다.

HTTP는 확장가능한 프로토콜이다. 이 확장가능성(extensibility)을 통해서 응용 계층 프로토콜(TCP 또는 TLS-encryped TCP연결)과 같은 다른 전송 프로토콜 또한 이용이 가능하다. 또한, 하이퍼텍스트 문서 뿐 만 아니라 이미지와 비디오 같은 컨텐츠도 서버와의 통신에서 송수신이 가능하다.

> `Tranport Layer Security` : Secure Socket Layer(SSL)으로도 알려진 이 프로토콜은 이메일, 웹 브라우징, 메세징 등 다른 프로토콜에서의 데이터 도청 및 변경으로 부터 보안을 약속한다.

> `Transmission Control Protocol` : TCP는 전송 제어 프로토콜로써, 두 host가 데이터 전송함에 있어 무결성을 보장한다.

<br>

### 웹 동작과정

<img src="https://github.com/93jpark/dev-interview-study/blob/main/assets/images/network/network_http_workflow.jpeg" width="600" height="400">

##### 1. URL 검색

유저가 웹 브라우저의 검색창에 URL주소를 입력한다.

<img src="https://github.com/93jpark/dev-interview-study/blob/main/assets/images/network/url_format.png" width="600" height="140">

URL은 위와 같은 형식으로 구성된다.

> 프로토콜 별 포트번호

| 프로토콜 | 포트번호 | 프로토콜 | 포트번호 |
| :------: | :------: | :------: | :------: |
|   DHCP   |    67    |  Telent  |    23    |
|   NBNS   |   137    |   SMPT   |    25    |
|   DNS    |    53    |   HTTP   |    80    |
|   SNTP   |   123    |  HTTPS   |   443    |
|   SNMP   |   161    |   FTP    |    21    |

<br>

##### 2. DNS서버와 IP주소

DNS서버에는 사용자가 적은 URL주소의 도메인 네임에 해당하는 IP 주소가 등록된다.

> dig 명령어를 통해 알아본 github.com의 DNS Lookup 결과
> <img src="https://github.com/93jpark/dev-interview-study/blob/main/assets/images/network/dig_dns_lookup.png" width="250" height="300">
> github.com의 IP주소는 '20.200.245.247'으로 확인된다.

클라이언트는 DNS서버에 사용자가 요청한 도메인 주소에 대한 물리주소(IP주소)를 가져온다.

<br>

##### 3. 클라이언트-서버 TCP 연결

HTTP 요청 메시지를 전송하기 위해 클라이언트-서버 간 통신 채널을 만든다.

> 3-way-handshake
>
> 1. Clinet -> Server : 접속을 요청하는 SYN패킷 전송
> 2. Server -> Client : 접속 요청을 수락 후 접속 요청하는 쪽에 포트를 열어달라는 SYN, ACK 패킷 전송
> 3. Client -> Server : 수신이 정상적으로 이루어졌다는 ACK패킷 전송

<br>

##### 4. 클라이언트의 HTTP요청 메시지

클라이언트는 Header와 Body로 구성된 HTTP 요청 메시지를 전송한다.
`HTTP 메세지`는 ASCII 형식으로 인코딩된 텍스트 데이터이며, 클라이언트-서버 사이에서 어떻게 데이터를 교환할지 명세한다.

###### HTTP Request(요청)

```
GET /search?q=hello&hl=ko HTTP/1.1
User-Agent: Mozilla/4.0 (compatible; MSIE5.01; Windows NT)
Host: www.google.com
Accept-Language: en-us
```

`HTTP request`는 클라이언트에서 서버로 전송되는 메세지로, 어떠한 action을 요청하는지 명시한다.
첫줄에는 HTTP method, 요청 타깃, HTTP 버전으로 구성된다.

- HTTP method - GET,PUT과 같은 서버를 통해 수행할 동작이 명시된다.
- Request target - HTTP method에 따라 URI 또는 '?'으로 시작하는 QueryString이 명시된다.
- HTTP version - HTTP 버전에 따라 나머지 부분의 구조가 달라진다.

<br>

###### HTTP Headers

```
Get /test/test.htm HTTP/1.1
Accept: */*
Accept-Language: ko
Accept-Encoding: gzip, deflate
If-Modified-Since: Fri, 21 Jul 2006 05:31:13 GMT
If-None-Match: "734237e186acc61:a1b"
User-Agent: Mozilla/4.0(compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 1.1.4322; InfoPath.1)
Host: localhost
Connection: Keep-Alive

HTTP/1.1 200 OK
Server: Microsoft-IIS/5.1
X-Powered-By: ASP.NET
Date: Fri, 21 Jul 2006 05:32:01 GMT
Content-Type: text/html
Accept-Ranges: bytes
Last-Modified: Fri, 21 Jul 2006 05:31:52 GMT
ETag: "689cb7f885acc61:a1b"
Content-Length: 101
```

`HTTP header`는 key:value형식으로 구성되며, 아래의 header들로 나뉘어진다.

- <strong>General Header</strong>
  요청 및 응답 메세지 모두에서 사용되는 일반 목적의 헤더 항목

  - Date, Connection, Cache-control, Pragma, Trailer

- <strong>Entity Header</strong>
  요청/응답 메세지에서 사용가능한 엔티티(콘텐츠, 본문, 리소스 등)에 대한 설명
  | 이름 | 설명 | 예시 |
  | :-----: | :---: | :--- |
  | Content-Type | 해당 개체에 포함되는 미디어 타입 정보 | Content-Type: text/html; charset-latin-1 |
  | Content-Language | 해당 개체와 호환되는 사용자 언어 | - |
  | Content-Encoding | 해당 개체 데이터의 압축 방식 | Content-Encoding: gzip, defalte |
  | Content-Length | 해당 개체의 바이트 길이 | - |
  | Content-Location | 해당 개체의 실제 위치 | - |
  | Content-Disposition | 응답 Body를 브라우저에 표시하는 방법 | Content-Disposition : inline<br>Content-Disposition : attachment; filename='file_name.scv' |
  | Content-Security-Policy | 다른 외부 파일을 로드할 경우, 차단할 소스와 불러올 소스 명식 | Content-Security-Policy: default-src https: |
  | Location | 리소스가 리다이렉트된 때에 이동된 주소 | HTTP/1.1 302 Found Location: /|
  | Last-Modified | 리소스를 마지막으로 갱신한 일시 | - |
  | Transfer-Encoding | 동적으로 생성되어 Body의 길이를 모르는 경우 나누어 전송 | - |

- <strong>Request Header</strong>
  HTTP 요청 메시지에서만 나타나며, 클라이언트와 관련된 데이터를 담고 있다.
  | 이름 | 설명 | 예시 |
  | :-----: | :---: | :--- |
  | Host | 요청하는 호스트에 대한 이름 및 포트번호 | - |
  | User-Agent | 클라이언트 소프트웨어 정보 | - |
  | From | 클라이언트 사용자 메일 주소 | Content-Encoding: gzip, defalte |
  | Cookie | 서버에 의해 Set-Cookie로 클라이언트에 설정된 쿠키 정보 | - |
  | Referer | 바로 직전에 머물렀던 웹 링크 주소 | - |
  | If-Modified-since | 제시한 일시 이후 변경된 리소스를 취득 요청 | - |
  | Authorization | 인증토큰(JWT)을 서버로 보낼때 사용하는 헤더 | 토큰종류 + 실제 토큰문자 |
  | Origin | 서버로 POST요청 보낼때, 요청이 어느 주소에서 시작되었는지 명시 | - |

> Reference:
> https://gmlwjd9405.github.io/2019/01/28/http-header-types.html > https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages

<br>

##### 5. 클라이언트-서버 TCP 연결 해제

기존에 생성된 클라이언트-서버 통신 채널의 연결을 해제한다.

> 4-way-handshake
>
> 1. Clinet -> Server : 연결을 해제하기 위한 FIN패킷 전송
> 2. Server -> Client : 연결 종료를 확인했다는 ACK패킷 전송, 통신이 종료될때까지 대기
> 3. Server -> Client : 통신이 종료되었을 때, FIN패킷 전송
> 4. Client -> Server : 통신 해제를 확인했다는 ACK패킷 전송

<br>

##### 6. 서버의 응답 처리

HTTP Request 메시지에 따라 서버에서 필요한 비즈니스 로직을 수행하고 데이터를 가공하는 작업을 수행

<br>

##### 7. 클라이언트-서버 TCP 연결

앞서 HTTP Request를 전송하기 위해 만들었던 통신채널을 다시 클라이언트-서버 연결

##### 8. 서버의 HTTP응답 메시지

HTTP Request 메시지에 따른 Response 메세지를 리소스/응답코드를 함께 전송

###### HTTP Response

```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Content-Length: 3423

<html>
    <body>...</body>
</html>
```

`HTTP Response`메세지는 첫줄에 프로토콜의 버전, 상태코드, 상태 메세지로 구성된다. Header는 Request와 동일한 구조를 지니며, Body는 상태코드에 따라 달라진다.

<br>

##### 9. 클라이언트-서버 TCP 연결 해제

5의 TCP 연결 해제 작업을 반복한다.

<br>

##### 10. 클라이언트의 응답메세지 출력

웹 브라우저를 통해 응답 받은 메시지의 Body 데이터를 나타낸다.

<br>

### HTTP Method

`HTTP Method`는 클라이언트가 웹 서버에게 사용자 요청의 목적이나 종류를 알리는 수단을 말한다.
최초의 HTTP 0.9는 GET메소드만 존재하였지만 버전이 증가됨에 따라 다양한 메소드들이 추가되었다.

| Method  |                       Description                        |
| :-----: | :------------------------------------------------------: |
|   GET   |                       리소스 조회                        |
|  POST   |      요청데이터 처리, 주로 데이터를 등록할 때 사용       |
|   PUT   |       리소스를 변경하며 해당 리소스가 없다면 생성        |
|  PATCH  |              존재하는 리소스의 일부만 변경               |
| DELETE  |                       리소스 삭제                        |
|  HEAD   | GET과 동일하나 메세지 부분을 제외한 상태줄, 헤더만 반환  |
| CONNECT |      대상 자원으로 식별되는 서버에 대한 터널을 설정      |
|  TRACE  | 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 수행 |
| OPTIONS | 대상 리소스에 대한 통신 가능 옵션을 설명(CORS에서 사용)  |

#### HTTP Method 속성

- `안전(Safe)` : 반복해서 메소드를 호출하더라도 리소스가 변경되지 않음
  - GET메소드는 데이터를 변경시키지 않는 메소드임으로 안전함
- `멱등(Indempotnet)`: 메소드를 계속 호출해도 결과가 동일함 ➡️ f(f(x)) = f(x)
  - GET: 한 번 조회하든, 여러번 조회하든 같은 결과가 조회됨
  - PUT: 결과를 대체함. 따라서 같은 요청을 반복해도 최종결과는 같음
  - DELETE: 결과를 삭제함. 같은 요청을 반복해도 삭제된 결과는 같음
  - POST: 멱등이 아님. 반복 호출 시 중복해서 비즈니스 로직이 수행될 수 있음.
- `캐시가능(Cacheable)`: 캐싱을 통해 데이터를 효율적으로 가져올 수 있다.
  - GET,HEAD,POST,PATCH가 캐시가능하나 GET/HEAD가 주로 캐싱에 쓰인다.

> Reference
> https://kyun2da.dev/CS/http-메소드와-상태코드/

<br>

### HTTP 상태코드

`HTTP 상태코드`는 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능이다.

| Status Code |     Name      |                              Description                               |
| :---------: | :-----------: | :--------------------------------------------------------------------: |
|     1xx     | Informational |                         요청이 수신되어 처리중                         |
|     2xx     |  Successful   |                             요청 정상 처리                             |
|     3xx     |  Redirection  |                   요청을 완료하려면 추가 행동이 필요                   |
|     4xx     | Client Error  | 클라이언트 오류 - 잘못된 문법 등으로 인해 서버가 요청을 수행할 수 없음 |
|     5xx     | Server Error  |              서버 오류 - 서버가 정상 요청을 처리하지 못함              |

> reference :
>
> > https://mangchhe.github.io/web/2021/02/19/HttpActionProcess/
> > 인프런 - 모든 개발자를 위한 HTTP 웹 기본 지식(김영한)

---

![](https://velog.velcdn.com/images/huunguk/post/1f9be31e-42a2-493e-b1cc-03a3c2cb30f4/image.png)

## HTTP

웹상에서 **클라이언트와 서버 간에 요청/응답**으로
**데이터를 주고 받을 수 있는 프로토콜**이다.

클라이언트가 HTTP 프로토콜을 통해 서버에게 요청을 보내면
서버는 요청에 맞는 응답을 클라이언트에게 전송한다.

이때 HTTP 메소드는 서버가 요청을 수행하기 위해
해야할 행동을 표시하는 용도로 사용한다.

이 HTTP 메소드 중에서 GET과 POST의 특징과 차이점을 알아보겠다.

### GET

GET은 **서버로부터 정보를 조회하기 위해** 설계된 메소드이다.

GET 요청을 전송할 때 필요한 데이터를 Body에 담지 않고, 쿼리스트링을 통해 전송한다.
요청하는 데이터가 `HTTP Request Message`의 **Header** 부분에 url이 담겨서 전송된다.

URL의 끝에 `?`와 함께 이름과 값으로 쌍을 이루어 request를 보내게 되며
이러한 방식의 파라미터를 `쿼리스트링`이라고 부른다.

(만약, 요청 파라미터가 여러 개이면 `&`로 연결한다.)

> 쿼리스트링 : URL의 뒤에 입력 데이터를 함께 제공하는 가장 단순한 데이터 전달 방법

하지만 이런 방식은 url이라는 공간에 담겨가기 때문에
전송할 수 있는 **데이터의 크기가 제한적**이다.

또 **보안이 필요한 데이터**에 대해서는
그대로 url에 노출되므로 **`GET` 방식은 적절하지 않다.**

### POST

POST는 **리소스를 생성/변경하기 위해 설계**되었다.
POST방식의 request는 `HTTP Request Message`의 **Body** 부분에
데이터가 담겨서 전송된다.

길이의 제한 없이 데이터를 전송할 수 있으므로
데이터의 크기가 GET 방식보다 크고 내용이 눈에 보이지 않아 보안면에서 POST가 낫다.
_(하지만 보안적인 측면에서는 암호화를 하지 않는이상 고만고만하다.)_

### GET과 POST의 차이

**GET은** Idempotent / **POST는** Non-idempotent하게 설계되어잇다.

> Idempotent(멱등)은 수학이나 전산학에서 연산의 한 성질을 나타내는 것으로 => 연산을 여러 번 적용하더라도 결과가 달라지지 않는 성질

즉, 멱등이라는 것은 **동일한 연산을 여러 번 수행하더라도 동일한 결과가 나타나야한다.**

#### Get => Idempotent

Get이 Idempotent하도록 설계되었다는 것은 **서버에게 동일한 요청을
여러번 전송하더라도 동일한 응답**이 돌아와야 한다는 것을 의미한다.

이에따라 GET은 주로 **조회를 할 때에 사용**해야한다.

예를들어, 브라우저에서 웹페이지를 보거나, 게시글을 읽는 등
**조회하는 행위를 GET으로 요**청한다.

#### POST -> Non-Idempotent

POST는 Non-Idempotent이기 때문에 **서버에게 동일한 요청을
여러번 전송해도 응답은 항상 다를수가 있다.**

이처럼 POST는 **서버의 상태나 데이터를 변경시킬때** 사용된다.

게시글을 쓰고, 저장이 되고, 삭제하면 해당 데이터가 없어지는 등
POST로 요청하면 서버의 무언가는 변경되도록 사용된다.

## Summary

### GET

서버에서 데이터를 가져와서 **보여주는 용도**일뿐 서버의 **값이나 상태를 변경하지 않는다.**

### POST

서버의 값이나 상태를 **변경하기 위해** 또는 추가하기 위해서 사용된다.

---

# 주소창에 naver.com을 치면 일어나는 일!?

## 사전 개념정리

### 인터넷 브라우저란?

웹 서버와 통신하여 인터넷 사이트 및 다양한 컨텐츠들을
볼 수 있도록 지원해주는 소프트웨어 프로그램!

현재 가장 사용되는 **Chrome**을 포함한 **Safari, Firefox, 오페라** 등이 있다.

### DOM 트리란?

문서 객체 모델의 줄임말로, **객체로 표현된 HTML 문서**이다.
**브라우저는 HTML 문서를 바로 읽을 수 없기 때문에**
이를 객체 형태로 바꾸어 읽을 수 있게 **트리 구조로 변환해주어야** 하는데
이것이 **DOM 트리**이다.

DOM 트리 내 하나의 객체는 노드라고 부르며, 4가지 노드로 구성되어있다.

1. 문서 노드 : 트리의 최상위 객체
2. 요소 노드 : HTML 요소 (태그)를 객체로 표현
3. 어트리뷰트 노드 : HTML 요소의 'Attribute'를 객체로 표현
4. 텍스트 노드 : HTML 요소의 '텍스트'를 객체로 표현

DOM 트리는 **최상위 노드**인 '문서 노드'에서 부터 **아래 방향으로 순차적으로 탐색**되며,
JS를 통해 **HTML 문서에 접근할 때** 또는 **페이지를 조작하는 이벤트가 발생**할 때 이 과정이 일어난다.

그리고 **DOM 트리 생성과정에서 브라우저는 HTML 문서에 있는 에러들을 자동으로 처리**해준다.

### IP 주소

> 인터넷에 연결되어 있는 장치(컴퓨터, 스마트폰, 타블릿, 서버 등)들은
> 각각의 장치를 식별할 수 있는 주소를 갖고 있는데 이것을 ip라고 한다.
> 예)115.68.24.88, 192.168.0.1

- IP 주소란 많은 컴퓨터들이 **인터넷 상에서 서로를 인식**하기 위해 **지정받은 식별용 번호**이다
- 현재 IPv4버전 (32bit)로 구성돼있으며, 한번씩 들어봤을 법한 127.0.0.1 같은 주소를 말한다

- 시간이 갈수록 IPv4 주소의 부족으로 IPv6가 생겼는데, 128비트로 구성돼있기 때문에 IP 주소가 부족하지 않다는 특징이 있다

### 도메인 네임(Domain Name)

> ip는 사람이 이해하고 기억하기 어렵기 때문에, 이를 위해
> **각 ip에 이름을 부여**할 수 있게 했는데, 이를 **도메인**이라고 한다.
> 즉, **네트워크상에서 컴퓨터를 식별하는 호스트명**을 말한다.

- IP 주소는 12자리의 숫자로 돼있어서 사람이 외우기 힘들다는 단점이 있다
- 도메인 네임은 'naver.com'처럼 **몇 개의 의미있는 문자**들, **.의 조합**으로 구성

- 도메인 네임은 사람의 **편의성**을 위해 만든 주소이며, 실제로는 컴퓨터가 이해할 수 있는 **IP 주소로 변환하는 작업이 필요함**
- 이때 사용할 수 있도록 미리 도메인 네임과 함께 해당하는 **IP 주소값을 한 쌍으로 저장하고 있는 데이터베이스를 DNS라고 부른다.**
  - 도메인 네임으로 입력하면 **DNS를 이용해 컴퓨너는 IP 주소를 받아 찾아간다.**

---

## 본론, Naver.com 치면 일어나는 일

3단계로 방식을 나눌 수 있다.

## 1. 주소창에 입력한 텍스트 정보 확인

대부분 인터넷 브라우저는 자사 주소창을 검색창과 동일하게 사용하고 있다.
대표적으로 가장 많이 사용되고 있는 Chrome은 주소창의 구글의 검색창으로 쓰고 있다.

브라우저는 사용자가 주소창에 어떤 텍스트를 입력했을 때, 이 텍스트가 **검색어**인지 **URL**인지 우선적으로 확인한다.

- 입력한 텍스트가 **검색어**이면 => 브라우저는 검색 엔진의 URL에 검색어를 포함한 주소로 페이지를 이동

- 입력한 텍스트가 **URL**이면 => 브라우저 엔진에서 네트워크 호출을 수행

> 즉, 주소창에 `naver.com`을 입력한 경우 **브라우저는 네트워크 호출을 수행**하게 되는것이다

## 2. 네트워크 호출

#### 브라우저가 왜 네트워크 호출을 해야하는 걸까?

브라우저가 사용자에게 '네이버'사이트를 화면에 보여주려면 네이버의 HTML, css, img, script 등 여러 데이터를 가지고 있어야 하는데 현재 브라우저엔 이러한 정보가 없다**(데이터들은 네이버 서버 컴퓨터에 존재함)**

그러한 이유로 브라우저는 네이버 서버와의 네트워크 통신을 위해 데이터들을 가져와야 한다.

이 작업을 수행하기 위해선, 브라우저는 우선 네이버 서버가 있는 컴퓨터의 IP 주소부터 파악할 필요가 있다.
_(친구의 집에 찾아가려면 집 주소을 알야아 하는것과 유사)_

### 정리

- 네이버 서버 주소를 알기 위해 **네임 서버**(name server)와 통신

- 알아낸 주소를 네이버 서버와 통신하여 필요한 데이터 응답 받기

### **네이버 서버의 주소를 찾는 과정**

네이버 서버 주소를 알기 위해 **클라이언트(사용자 컴퓨터)** 에서는

1. 자신의 host 파일에서 **도메인 네임**에 대응하는 IP주소가 있는지 파악

2. 없다면, 네임 서버에 **'네이버의 IP 주소를 알려줘' 요청**을 보냄

여기서 **도메인 네임** 이란? URL `www.naver.com`에서 `naver.com`을 해당한다.
인터넷은 컴퓨터 주소인 ip 주소를 기반으로 동작하는데
우리가 사용할 땐 사용하기 쉽도록 문자로 이루어진 도메인 네임을 사용한다.

따라서 도메인 네임을 ip 주소로 변환해 주는 환경인 DNS가 반드시 필요한데
DNS를 운영하는 장치를 **네임 서버** 혹은 **DNS 서버**라고 한다.

즉, **네임서버는 도메인 주소에 대응한 IP주소를 찾아주는 역할**을 하며
**클라이언트는 일반적으로 네임 서버의 IP 주소를 갖고** 있고
따라서 **클라이언트는 네임 서버와 통신이 가능**하고, `naver.com`에 해당하는
**IP 주소를 요청 및 응답 받을 수 있다**.

### 네이버 서버와 통신하여 필요한 데이터를 받는 과정

클라이언트는 네이버 서버의 IP 주소를 알게 되어 네이버 서버와 통신할 수 있게 되었다.
클라이언트 브라우저는 **네이버 서버**에 데이터를 요청하는 **`HTTP Request`를 보낸다.**

요청을 받은 네이버 서버는 클라이언트가 요청한 **문서를 찾아 읽고**, 이를 바이트 형태로 변환**텍스트** 후 클라이언트로 **HTTP Reply (HTTP Responese)를 보낸다.**

## 3. 렌더링 작업

브라우저 엔진은 네이버 서버로부터 응답받은 **데이터에 바이러스가 있는지 검사**한 후
(데이터는 바이트 형태의 텍스트 문서이므로, 브라우저 엔진이 읽을 수 있다.)

브라우저 엔진은 **렌더링 엔진**에게 해당 데이터를 해석하고
**웹 페이지를 화면에 띄울것을 요청**한다.

요청 받은 렌더링 엔진은 받은 데이터를 바탕으로 **`렌더링 프로세스`**를 수행하고
이 과정이 끝나면 **브라우저 엔진에게 작업 완료를 알린다.**

**그럼 마침내 화면에 네이버 페이지가 보여지게 되는것이다!**

## 렌더링 프로세스?

렌더링 엔진은 **브라우저 엔진으로부터 요청받은 내용을 화면에 표시**해주는 역할을 한다.

렌더링 과정은 **4가지** 과정으로 이루어진다.

1. HTML 파싱하여 DOM 트리 구축 / CSS 파싱하여 CSSOM 트리 구축 (+JS파싱)
2. DOM트리와 CSSOM 트리를 통해 랜더 트리 구축
3. 랜더 트리 배치 (Layout/Reflow)
4. 랜더 트리 그리기 (Paint)

## 파싱 이란?

브라우저는 HTML, CSS 등 단순한 텍스트 문서를 이해하지 못한다.
따라서 이 문서를 **브라우저가 이해할 수 있는 구조로 변환해주는 과정**이 필요한데
이를 **파싱**이라고 한다.

파싱은 '어휘 분석', '구문 분석' 두 가지 과정으로 구분할 수 있다.

1. 어휘 분석 : 문자열을 의미 있는 작은 단위인 **토큰**으로 분해하는 과정
2. 구문 분석 : 문자열의 문법에 따라 토큰 간의 위계관계를 분석하여 parsing 트리를 생성하는 과정

> 파싱 결과 생성되는 트리 형태를 parse 트리, parsing 트리, concrete syntax 트리 등 다양한 용어로 부른다.
> (parse 트리는 토큰화 된 문자열의 단순한 트리에 불과하므로, 바로 사용할 순 없다.)
> 따라서 이 Parse 트리를 dom 트리로 바꾸어 사용한다.

![](https://velog.velcdn.com/images/huunguk/post/c439630b-7b7b-4e6e-a2d2-9433067455ca/image.png)

### Html 파싱 => DOM 트리 생성

#### Html 파싱 과정

1. 서버에서 **바이트 형태** 문서를 응답받는다.

2. 지정된 인코딩 방식(UTF-8)에 따라 **문자열** 변환 (`<meta charset="UTF-8">`)
3. 변환된 문자열을 **토큰**으로 분해한다.
4. 토큰을 내용에 따라 **객체(노드)**로 변환
5. 객체를 **트리 구조** 구성하여 **DOM 생성**

사용자의 만족도를 높이기 위해 렌더링 엔진은 **HTML 문서가 모두 파싱될 때 까지 기다리지 않고** 파싱 이후 과정인 **배치와 그리기를 미리 진행**한다.

### Css 파싱 => CSSOM 트리 생성

> html 파싱중 css 문서를 가져오는 `link` 태그를 만나면, dom 생성이 잠시 중단되고 해당 CSS의 파싱 과정이 시작된다.

CSS 파서는 서버에서 수신받는 CSS 문서를 파싱하여 **CSSOM 트리를** 생성
CSSOM 트리의 노드는 DOM 트리 요소의 선택자에 맞춰 적용될 CSS 스타일 정보가 포함돼있다.

#### - CSS 파싱 과정

1. 서버에서 **바이트 형태** 문서를 응답받는다.

2. 지정된 인코딩 방식(UTF-8)에 따라 **문자열** 변환 (`<meta charset="UTF-8">`)
3. 변환된 문자열을 **토큰**으로 분해한다.
4. 토큰을 내용에 따라 **객체(노드)**로 변환
5. 객체를 **트리 구조** 구성하여 **DOM 생성**

> ** CSS 파싱 과정은 HTML의 파싱 과정과 동일하다.**

### Javascript 파싱

HTML 파싱 과정 중 `script` 태그를 만나면 **렌더링 엔진은 DOM 생성을 잠시 중지**하고
서버에서 해당 **JS 리소스를 브라우저 엔진으로부터 받아온다**.
그리고 JS 엔진에게 제어권을 넘겨며, 받아온 JS 리소스를 파싱하여
**AST(추상 구문 트리)** 를 생성하고 이를 바이트 코드로 변환해 실행한다.
파싱이 종료되면 렌더링 엔진은 다시 제어권을 돌려받고 DOM 생성을 이어나간다.

만일 `script` 태그를 `body` 태그에 작성할 경우, HTML 파싱이 끝나지 않는 상태에서
JS로 인해 DOM이 조작되어 에러가 발생할 위험이 있다.
따라서 `script` 태그는 반드시 `body` 태그 내부의 **최하단에** 위치해야 한다.
(혹은 `script` 태그에 `defer` 속성을 부여하는 방법도 있다.)

### Render Tree 생성

HTML이나 CSS의 파싱 과정이 끝나면 각 결과물인 DOM 트리와 CSSOM 트리를 서로 **결합하여 랜더 트리를 생성**한다.

![](https://velog.velcdn.com/images/huunguk/post/a154059a-e488-4d42-9d04-a4cbb1c268cf/image.png)

#### Render Tree 생성 과정

- `html`태그와 `body`태그를 처리하며 **랜더 트리 루트**를 구성

- **DOM**의 최상위 노드부터 순회하며 **화면에 보이지 않는 노드**를 랜더 트리의 구성에서 제외
- 화면에 보여지는 나머지 노드에 **CSSOM** 규칙을 찾아 일치하는 스타일을 적용한다.

### 레이아웃

랜더 트리 생성이 끝나면, 전체 웹 페이지 화면 안에서 랜더 트리 내 각 노드의 위치, 크기를 계산하고 이를 화면에 배치하는 레이아웃 과정이 진행된다.

즉, **랜더 트리의 노드들을 화면에 배치하는 과정**이다.

레이아웃은 전체의 배치과정이 필요한 **글로벌 레이아웃**, 일부 배치과정만 변경하는 **로컬 레이아웃**으로 나뉜다.

**글로벌 레이아웃은** 맨 처음 레이아웃이 발생할 떄, 초기 배치 이후 `font`와 같은 전역 스타일이 변경되거나 창이 리사이즈 될 때 발생한다.
초기 배치 이후 레이아웃 작업이 다시 일어나는것을 **리플로우**라고 한다.

반대로 로컬 레이아웃은 초기 배치 이후 일부 DOM 노드에 변경이 생기는 것처럼, **특정 부분만 재배치가 필요할때 발생한다.** 이는 일부 변경만으로 전체 배치과정이 다시 일어나 불필요한 낭비가 발생하는 상황을 막아준다.
즉, 로컬 레이아웃이 일어나는 경우는 모두 **리플로우**가 발생할 때이다.

### 페인트

**각 노드를 화면의 실제 픽셀로 변환해주는 작업을 의미한다.** 픽셀로 변환하는 과정을 **래스터화**라고 부른다.

페인트 과정중 화면의 특정 위치에 여러 노드가 겹치는 경우, 여러 레이어를 만들고 합성하는 방식으로 작업이 이루어지며, **페인트 과정이 끝나면 브라우저 화면에 네이버 페이지가 보이게 된다.**

> 참고

- [github 참고자료](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Network/%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90%20naver.com%EC%9D%84%20%EC%B9%98%EB%A9%B4%20%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94%20%EC%9D%BC.md)
- [ velog 참고자료](https://velog.io/@sylagape1231/%EC%A3%BC%EC%86%8C%EC%B0%BD%EC%97%90-naver.com%EC%9D%84-%EC%B9%98%EB%A9%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94-%EC%9D%BC%EC%9D%84-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EC%9E%90)
