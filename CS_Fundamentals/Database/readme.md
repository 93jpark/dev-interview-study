# 데이터베이스

 ## ◻ Index 란 무엇인가
 
 인덱스(Index)는 **데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조**입니다. 
 특정 컬럼(Column)에 인덱스를 생성하면, _해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장_ 됩니다. 
 인덱스는 책에서의 목차 혹은 색인이라고 생각하면 됩니다. 책에서 원하는 내용을 찾을 때 목차나 색인을 이용하면 훨씬 빠르게 찾을 수 있는데, 마찬가지로 테이블에서 원하는 데이터를 찾을 때 인덱스를 이용하면 빠르게 찾을 수 있습니다. 
 그러므로 `데이터 = 책의 내용`, `인덱스 = 책의 목차`, `물리적 주소 = 책의 페이지 번호` 라고 생각할 수 있습니다. 
 
## ◻ Index 의 자료구조

#### 1. 해시 테이블(Hash Table)Permalink
Key-Value 형태로 데이터를 저장하는 자료구조입니다. 내부적으로 배열(버킷)을 사용하여 데이터를 저장하기 때문에 빠른 검색 속도를 제공합니다. 데이터 탐색 시 해시 함수(Hash Function)를 이용해 Key에 해당하는 index 값을 구합니다. index를 이용하여 배열에 저장된 value에 접근하기 때문에 해시 테이블의 평균 시간복잡도는 O(1)입니다.
<p align="center"><img width="500" src="https://velog.velcdn.com/images/taeyeeya/post/ca3c4536-5d4d-4926-ab63-785ba977f34e/image.jpg"></p>
칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다. 
하지만 값을 변형해서 인덱싱 하므로 특정 문자로 시작하는 값으로 검색을 하는 전방 일치와 같이 값의 일부만으로 검색하고 할 때는 해시 인덱스를 사용할 수 없다. 
주로 메모리 기반의 데이터베이스에서 많이 사용한다. 

이미지 출처 - https://zorba91.tistory.com/293

#### 2. B+-Tree(Balanced Tree)Permalink
B+Tree는 DB의 인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조입니다. 
B+Tree는 모든 노드에 데이터를 저장했던 B-Tree와 다음과 같이 다른 특성을 가지고 있습니다. 
>- 리프 노트 (데이터노드)만 인덱스와 함께 데이터를 가지고 있고, 나머지 노드들은 데이터를 위한 인덱스만을 갖는다. 
- 리프 노드들은 연결 리스트로 연걸되어 있다.
- 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다. 


Hash테이블 방식은 O(1), B+-Tree방식은 O(logn)의 시간 복잡도를 가지지만, 일반적으로 데이터베이스에서는 B+-Tree방식을 사용한다. 그 이유는 해시함수는 등호(=)연산에만 특화 되었기 때문에 부등호 연산(<,>)이 자주 사용되는 데이터베이스 검새을 위해서는 해시테이블이 적합하지 않기 때문이다. 


## ◻ Primary index vs Secondary index (기본 인덱스와 보조 인덱스)

#### 클러스터형 인덱스 (Clustered Index)


> - 테이블당 하나만 생성 가능
- 행 데이터를 인덱스로 지정한 열에 맞춰서 자동으로 정렬함
> - 영어사전처럼 책의 내용 자체가 순서대로 정렬되어 있어 인덱스가 책의 내용과 같음

테이블에 클러스터 인덱스를 적용할 때마다 그 테이블에 정렬 작업이 수반된다. 
클러스터 인덱스는 Primary Key처럼 한 테이블에 한개만 생성할 수 있다. 
또한, 클러스터 인덱스는 데이터를 가리키는 포인터가 아닌 데이터를 저장한 블록의 포인터를 저장한다. 
<p align="center"> <img width="500" src="https://velog.velcdn.com/images/taeyeeya/post/98829e92-025b-4fba-9983-b31b4071ad93/image.jpg"></p>


#### 보조 인덱스 (비클러스터형 인덱스 / Nonclustered Index)
>- 테이블당 여러 개를 생성할 수 있다.
- 비클러스터형 인덱스는 그냥 찾아보기가 있는 일반 책과 같다.

비 클러스터 인덱스는 책의 색인(Index)과 같은 역할을 한다. 
데이터와 인덱스는 각각 다른 장소에 저장되므로 한 테이블에 여러 개의 비 클러스터 인덱스를 생성할 수 있다. 또한, 비 클러스터 인덱스는 데이터를 가리키는 포인터를 저장한다.
<p align="center"><img width="500" src="https://velog.velcdn.com/images/taeyeeya/post/a22c45fb-ca18-4eea-a762-f7ca79b5dd2d/image.jpg"></p>

### Cluster Index vs Nonclustered Index
|기준|Cluster Index|Nonclustered Index|
|---|:---:|:----:|
|속도|빠르다|느리다|
|사용 메모리|적다|많다|
|인덱스|인덱스가 주요 데이터|인덱스가 데이터의 사본(copy)|
|개수|한 테이블에 한 개|한 테이블에 여러 개 (최대 약 250개)|
|리프 노드|리프 노드 자체가 데이터|리프 노드는 데이터가 저장되는 위치|
|저장값|데이터를 저장한 블록의 포인터|값과 데이터의 위치를 가리키는 포인터|
|정렬|인덱스 순서와 물리적 순서가 일치|인덱스 순서와 물리적 순서가 불일치|

출처: https://www.geeksforgeeks.org/difference-between-clustered-and-non-clustered-index/
## ◻ Composite index (결합인덱스)

결합 인덱스란 인덱스를 생성할 때 두 개 이상의 컬럼을 합쳐서 인덱스를 만드는 것을 말합니다.

보통 결합인덱스는 아래와 같은 조건에서 자주 생성합니다. 

>- WHERE조건으로 사용되는 컬럼
- 다른 테이블과 조인 절에서 연결고리로서 사용되는 컬럼
- ORDER BY절에서 사용되는 컬럼

#### 결합 인덱스의 컬럼 설정 시 고려해야 할 우선순위
>- where절 조건에 많이 사용되는 컬럼이 우선시
- Equal('=')로 사옹되는 컬럼 우선
- 분포도가 좋은 컬럼을 우선
- 자주 이용되는 순서대로 결합 인덱스 컬럼의 순서 결정


## ◻ Index 의 성능과 고려해야할 사항

인덱스는 잘못 사용하면 오히려 성능이 저하될 수 있다고 한다. 
이는 인덱스를 생성하게 되면 INSERT, DELETE, UPDATE 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생하기 때문이다. INSERT의 경우 인덱스에 대한 데이터를 추가해야 하고, DELETE의 경우 인덱스에 존재하는 값은 삭제하지 않고 사용하지 않는다는 표시만 남게된다. 즉 ROW의 수가 그대로 남는다. 

실제 데이터가 10만인데 테이블에는 100만개의 데이터가 있을 수 있다는 것이다. 
UPDATE는 더 큰 문제가 발생한다. 인덱스에 대한 데이터를 추가하는 것은 물론 변경 전 데이터도 사용하지 않음으로 바꿔야 하므 INSERT, DELETE의 문제가 모두 발생한다. 

인덱스 데이터의 형식에 따라서도 성능이 달라질 수 있다. 데이터의 형식에 따라 인덱스를 만들었을 때 효율적인 데이터가 존재한다. 

예를 들어 이름, 나이, 성별 세가지의 필드를 갖고 있는 테이블을 생각해보자. 이 경우 이름에 대해서 인덱스를 생성하는 것이 효율적이다. 만약 성별을 기준으로 인덱스를 생성하면 제대로 인덱스의 기능을 할 수 없을 것이다. 

**따라서 인덱스는 다음과 같은 상황에서 사용하는 것이 좋다.**

>- 규모가 작지 않은 테이블
- INSERT, UPDATE, DELETE가 자주 발생하지 않는 칼럼
- JOIN이나 WHERE 또는 ORDER BY에 자주 사용되는 칼럼
- 데이터의 중복도가 낮은 칼럼

https://junhyunny.github.io/information/data-structure/db-index-data-structure/

## :memo: Table of Contents

- [반정규화](#📌-반정규화의-정의)
    - [반정규화 절차](#📜-반정규화의-절차)
    - [테이블 반정규화](#📘-테이블의-반정규화)
    - [칼럼 반정규화](#📗-칼럼의-반정규화)
    - [관계 반정규화](#📙-관계의-반정규화)
- [파티셔닝](#파티셔닝partitioning)
- [로우체이닝](#📕-로우체이닝)
- [파티셔닝 범위](#📏-파티셔닝의-범위)
- [파티셔닝 종류](#📐-파티셔닝의-종류)

- [Object-Relational-Mapping](#object-relational-mapping-orm)

<br>

---

<br>

## 📌 반정규화의 정의
> 정규화된 엔티티, 속성, 관계에 대해 시스템의 성능향상과 단순화를 위하여 <br>
> 데이터의 무결성이 깨짐을 무릎쓰고 데이터를 `중복, 통합, 분리` 등을 수행하는 모델링의 기법 
---
### 📜 반정규화의 절차
![sql](https://user-images.githubusercontent.com/80400157/200120588-6ce02b4c-b160-4949-a982-33c30a4799b9.jpg)

#### 1. 반정규화 대상조사
우선적으로 데이터의 양을 조사하고 그 데이터가 프로세서를 처리할 때 성능 저하가 일어나는지 확인합니다.<br>
그후 데이터가 대량이고 성능이 저하될것이라 예상이 된다면 그림에나온 4가지 경우를 고려하여 반정규화를 고려합니다.

####  2. 다른 방법유도 검토
가급적이면 데이터를 중복하여 데이터 무결성을 깨뜨릴 위험을 제어하기 위하여 반정규화를 결정하기 이전에<br>
성능을 향상시킬 수 있는 다른 방법을 고려하여 봅니다.

####  3. 반정규화 적용
충분한 조사와 판단을 통해 정규화를 적용한다면 반정규화를 하는 대상으로 테이블,속성,관계에 대해 적용하며<br>
중복 뿐만 아니라 추가, 분활, 제거 같은 포괄적인 방법을 적용한다.

### 📘  테이블의 반정규화
![table](https://user-images.githubusercontent.com/80400157/200121270-08db7d39-5a6a-48e9-932d-44cfec7c27cb.jpg)
---
### 📗 칼럼의 반정규화
![colum](https://user-images.githubusercontent.com/80400157/200121274-b7cb19bd-e727-4e0f-9041-9803fb05adb2.jpg)
---
### 📙 관계의 반정규화
![relation](https://user-images.githubusercontent.com/80400157/200121278-f94a8124-3a97-422a-aa17-b2d68a4834a2.jpg)
---
<br>

<br>

### 💡 반정규화 예시

![Inkedproblem1](https://user-images.githubusercontent.com/80400157/200121963-af1fbab0-8bed-467b-ad43-454054126f8d.jpg)
> 공급자와 전화번호, 메일주소, 위치는 1:M의 관계로 최근 변경된 값을 가져오기 위해서는 복잡한 조인이 발생한다 -> 아주 긴 SQL문이 작성된다
> 비정규화를 통해 최근에 변경된 값을 공급자에 위치시키면 아주 짧은 SQL문으로 조인 가능하다
---
<br>

![problem2](https://user-images.githubusercontent.com/80400157/200121966-9c9eb5ee-223e-4ab2-a4f3-60866e59225a.jpg)
> 서버 B에서 데이터를 조회할 때 빈번하게 서버 A의 부서번호를 조회 한다 -> 연계, 접수, 부서 테이블 모두 조인을 거쳐야 하며 <br>
> 다른 서버간에도 조인이 걸리게 되어 성능이 저하된다 그리하여 부서명으로 속성 반정규화를 함으로써 조회성능 향상
---

### 🏮 반정규화 유의사항
- 반정규화를 적용할때 데이터를 입력, 수정, 삭제 할때는 성능이 떨어지는 점을 기억해야 한다.
- 데이터의 무결성 유지에 주의를 해야한다.


## 파티셔닝(Partitioning)
- 파티셔닝이란 데이터베이스를 여러 부분으로 분할하는 것입니다.
- 큰 table이나 index를, 관리하기 쉬운 partition이라는 작은 단위로 물리적으로 분할하는 것을 의미합니다.

### 📜 개요
> 서비스의 크기가 점점 커지고 DB에 저장하는 데이터의 규모 또한 대용량화 되면서, <br>
> 기존에 사용하는 DB 시스템의 용량(storage)의 한계와 성능(performance)의 저하 를 가져오게 되었습니다. <br>
> 그로 인해 아래와 같은 문제점들이 발생합니다. 


<br>

## 📕 로우체이닝
![rowchaining](https://user-images.githubusercontent.com/80400157/200126315-0997369e-386e-4388-9579-cca86bd7d6bb.PNG)

---
<br>
 
### 📙 로우마이크레이션
![rowmigration](https://user-images.githubusercontent.com/80400157/200126313-108cdd07-f88c-432a-bce5-0d6ce893c6f5.PNG)

---
<br>

### 📗 하나의 테이블에 많은 수의 칼럼이 존재하는 경우
![tooManyColumn](https://user-images.githubusercontent.com/80400157/200126743-9aedf6ee-5a7f-4381-9c5d-c32290a00797.jpg)
- 데이터가 디스크의 여러 블록에 존재하게 되므로 디스크에서 데이터를 읽은 I/O량이 많아지게 되어 성능 저하가 발생합니다.
- 트랜잭션을 분석하여 적절하게 1:1 관계로 분리함으로써 성능향상이 가능합니다.

---
<br>

### 📘 하나의 테이블에 대량의 데어터가 존재하는 경우
- 많은 양의 데이터가 예상될 경우 파티셔닝을 적용하거나 PK에 의해 테이블을 분할하는 방법을 적용할 수 있습니다.

### 📏 파티셔닝의 범위
--- 
#### 1. RANGE PARTITION
- 가장 많이 사용하는 파티셔닝의 기준입니다.
- 대상 테이블이 날자 또는 숫자값으로 분리가 가능할때 사용합니다.
- 데이터를 쉽게 지우는 것이 가능하여 보관 주기에 따른 테이블관리가 용이합니다.
#### 2. LIST PARTITION
- 지점, 사업소, 사업장, 핵심적 코드값 등으로 구성되어있는 테이블이라면 적용할수 있습니다.
- 대용량 데이터를 특정값에 따라 분리 저장할 수는 있습니다.
- 하지만 보관주기에 따라 쉽게 삭제하는 기능은 제공될 수 없습니다.
#### 3. HASH PARTITION
- 파티션 키(Key)의 해시 값에 의한 파티셔닝이 이루어집니다.
- 파티션을 위한 범위가 없는 데이터에 적합합니다.
- 균등한 데이터 분할이 가능하지만 특정 데이터가 어느 Hash 파티션에 있는지 판단하기 어렵습니다.

<br>

### 📐 파티셔닝의 종류
--- 
#### 1. Horizontal Partitioning
![수평](https://user-images.githubusercontent.com/80400157/200127748-132b241d-89f7-4e38-904f-2a140129d53a.JPG)
- 같은 데이터베이스 내에서 하나의 큰 테이블을 쪼개 분산 저장합니다
- 데이터의 개수를 기준으로 나누어 파티셔닝합니다.
- 데이터의 개수가 작아지고 따라서 index의 개수도 작아지게 됩니다.
- Sharding과 비슷한 방법으로 데이터를 분산하지만 Sharding은 테이블을 쪼개 각각 다른 데이터베이스에 분산 저장합니다
#### 2. Vertical Partitioning
![수직](https://user-images.githubusercontent.com/80400157/200127749-60d53564-6589-4d53-834d-5f964708a329.JPG)
- 모든 컬럼들 중 특정 컬럼들을 쪼개서 따로 저장하는 형태를 의미합니다.
- 자주 사용하는 칼럼을 분리하여 성능을 향상합니다
- 조회 시 필요 없는 칼럼을 조회하지 않아도 되므로 성능상의 이점이 있습니다.
---

>Reference
https://code-lab1.tistory.com/202
https://gmlwjd9405.github.io/2018/09/24/db-partitioning.html
https://eehoeskrap.tistory.com/56
SQL 전문가 가이드 / 한국데이터산업진흥원



## Object-Relational Mapping (ORM)

(working on)

