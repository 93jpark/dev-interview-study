이진 검색(binary search)

오름차순 또는 내림차순으로 정렬된 배열에서 검색하는 알고리즘

​

이진 검색 특징

선형 검색보다 빠르게 검색 가능

데이터를 삽입하거나 지울 수 있게 해주는 데이터 구조

 

오름차순에서 x 검색

배열의 중앙에 위치한 요소를  확인하여 검색하려는 값이 중앙요소보다 큰 경우 검색 범위 중앙에서 우측에 값을 대상으로 범위를 좁혀가며 다시 탐색을 진행한다.

이진 검색은 검색을 반복할 때마다 검색 범위가 절반이 되므로 검색에 필요한 비교 횟수의 평균값은 log n

검색에 실패한 경우는 [ log(n + 1) ] 회, 검색에 성공한 경우는 대략 log n - 1 회

위의 [log( n + 1) ] 에 사용한 [  ]는 천장 메서드 (ceiling function) 를 나타내는 기호이다. 즉, [x] 는 x의 천장 메서드이며, x보다 크거나 같으면서 가장 작은 정수이다.

 

복잡도(complexity) 

알고리즘의 성능을 객관적으로 평가하는 기준을 복잡도(complexity) 라고 한다.

​

(1) 공간 복잡도(Space Complexity) : 알고리즘에 사용되는 메모리 공간의 총량, 메모리 사용량에 대한 분석 결과

(2) 시간 복잡도(Time Complexity) : 알고리즘에 사용되는 연산횟수의 총량, 속도에 대한 분석 결과

​

만약 시간복잡도를 연산횟수가 아닌 "실행시간"으로 분석할 경우

 1) 측정을 위한 완성된 프로그램이 필요하다.

 2) 모든 플랫폼(그냥 컴퓨터 or 슈퍼 컴퓨터)에서 동일한 결과를 산출하지 못한다.

​

"연산횟수"를 바탕으로 시간복잡도를 산출할 경우

1) 실행이 필요하지 않다.

2) 수도코드로 계산이 가능하기 때문에 h/w, s/w 가 필요하지 않다. 

3)모든 플랫폼에서 동일한 결과를 산출한다.

 

시간복잡도

O(big-O, big-oh)

시간의 상한

Ω(big-Ω, big-omega)

등가 개념 혹은 하한, 배열의 모든 값을 출력하는 알고리즘은 Ω(N) 뿐만 아니라 Ω(logN) 혹은 Ω(1)로도 표현할 수 있다. 

θ(big-θ, big-theta)

θ는 O와 Ω 둘 다 의미, 어떤 알고리즘의 수행시간이 O(N)이면서 Ω(N)이라면, 이 알고리즘의 수행시간을 θ(N)로 표현할 수 있다.

​

선형 검색의 시간 복잡도

static int seqSearch(int[] a, int n, int key) { int i = 0; while(i < n) { if(a[i] == key) { return i; } i++; } return -1;}

 

변수 i에 0을 대입하는 횟수는 처음 한번이다. 따라서 복잡도는 O(1)로 표기한다. 메서드에서 값을 반환하는 return i; 이나 return -1;도 한번만 실행하기 때문에 O(1)로 표기한다.

배열의 맨끝에 도달했는지 판단하는 while(i < n) 와 현재 검사하고 있는 요소와 값이 같은지 판단하는 if(a[i] == key) 의 평균 실행 횟수는 n/2 이다. 컴퓨터에서 n/2와 n의 차이는 무의미하기 때문에 이처럼 n에 비례하는 횟수만큼 실행하는 경우의 복잡도는 O(n)으로 표기한다. 여기서 n(데이터 수) 가 점점 커지면 O(n)에 필요한 계산 시간은 n에 비례하여 점점 길어지는데 이와 달리, O(1)에 필요한 계산 시간은 변하지 않는다.

​

일반적으로 O(f(n)) 과 O(g(n))의 복잡도를 계산하는 방법

O(f(n)) + O(g(n)) = O(max(f(n), g(n))) 

​

2개 이상의 복잡도로 구성된 알고리즘의 전체 복잡도는 차원이 더 높은 쪽의 복잡도를 우선시 한다.

O(1) + O(n) + O(n) + O(1) + O(n) + O(1) = O(max(1, n, n, 1, n, 1)) = O(n)

 

 

이진 검색의 시간 복잡도 

static int binSearch(int[] a, int n, int key) { int pl = 0; int pr = n - 1; do { int pc = (pl + pr) / 2; if (a[pc] == key) return pc; else if (a[pc] < key) pl = pc + 1; else pr = pc - 1; } while(pl <= pr); return -1; }

 

O(1) + O(1) + O(log n) + O(log n) + O(1) + O(log n) + ... + O(1) = O(log n) (이진 검색법을 이용하면 검색할 요소의 범위를 절반씩 좁힐 수 있다.)


복잡도와 증가율

​

공간복잡도

공간복잡도는 시간복잡도와 평행선을 달리는 개념이다. 크기가 n인 배열을 만들고자 한다면, O(n)의 공간이 필요하다. 

 

 

 

​

[출처] [자료구조] 시간 복잡도와 공간 복잡도|작성자 호로요이이 / 자료구조 - 이진 검색(binary search), 시간 복잡도(time complexity), 공간 복잡도(space complexity) (tistory.com) / 시간복잡도 big-O big-Ω big-θ 공간복잡도 (tistory.com) / [알고리즘] Binary Search Tree 이진탐색 트리 : 필수기본정리 - 탐색,삽입,삭제, 검색연산, 삭제연산 - Kotlin — Under Tech Blog (tistory.com)

​

[출처] 이진검색, 복잡도|작성자kyh990721

