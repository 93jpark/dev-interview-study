## 메모리 관리 전략
### 메모리 관리 배경
  다수의 프로세스들을 사용하면서 메모리 관리의 중요성은 대두되었다. 멀티 프로세스 환경에서는 보다 좋은 성능을 위해서 다수의 프로그램을 주 메모리에 올려놓아야 한다. 이때 메모리에 어느곳에 프로그램을 넣어주고, 다시 하드디스크로 보내는 역할을 운영체제에서 담당한다. 그렇기 때문에 적절한 메모리 위치에 프로그램을 적재하지 못할 경우 문제가 발생하게된다. 또한 메모리가 변경될 때 어떻게 하면 더 효율적이고 메모리 낭비를 방지 할 수 있는가에 대한 문제를 해결하기 위해 메모리 관리를 해야한다. 

  >프로세스 : 실행중인 프로그램으로 운영체제로부터 자원(주소공간, 파일, 메모리)를 할당받는 작업의 단위를 말한다.

### 1.1 Swapping
  메모리의 관리를 위해 사용되는 기법. 
  표준 Swapping 방식으로는 round-robin과 같은 스케줄링의 다중 프로그래밍 환경에서 cpu할당 시간이 끝난 프로세스의 메모리를 보조 기억장치(하드 디스크)로 내보내고 다른 프로세스의 메모리를 불러 들일 수 있다.

  * 주기억장치(RAM)로 불러오는 과정을 swap-in
  * 보조 기억장치로 내보내는 과정을 swap-out
  * swap 에는 큰 디스크 전송시간이 필요하기 때문에 현재에는 메모리 공간이 부족할때 Swapping이 시작된다. 

  >round-robin Scheduling :시분할 시스템을 위해 설계된 스케줄링의 하나로서, 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위(Time Quantum/Slice)로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘이다. 즉, 컴퓨터 자원을 사용할 수 있는 기회를 프로그램 프로세스들에게 공정하게 부여하기 위한 한 방법으로서, 각 프로세스에 일정시간을 할당하고, 할당된 시간이 지나면 그 프로세스는 잠시 보류한 뒤 다른 프로세스에게 기회를 주고, 또 그 다음 프로세스에게 하는 식으로, 돌아가며 기회를 부여하는 운영방식이라 풀어 말할 수 있다. (실시간 시스템에 유리함)
  
  ![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbJgSCQ%2FbtqIXfO9brG%2FuGaa8Zqmvt2OnhyCKiDKIK%2Fimg.png)

### 1.2 단편화
프로세스들이 메모리에 적재되고 제거되는 일이 반복되다보면 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 작은 자유공간들이 늘어가게 되는데, 이것이 단편화이다. 단편화는 2가지 종류로 나뉜다.

* 외부 단편화 : 프로세스들이 메모리를 차지하는 과정에서 외부에 여러 개로 작게 나누어진 공백이 생겨서 메모리를 할당할 수 없는 상태가 되는 것. 메모리 공간 중 사용하지 못하게 되는 일부분. 
* 내부 단편화 : 프로세스가 사용하는 메모리 공간에 포함된 남는 부분. 
* 압축 : 외부 단편화를 해소하기 위해 프로세스가 사용하는 공간들을 한쪽으로 몰아 자유공간을 확보하는 방법론. 작업 효율이 좋진 않다. 

### 2. Paging

논리 메모리를 페이지 단위로 나누어서 물리 메모리에 같은 크기인 프레임과 맵핑하여 사용하는 것을 의미한다. 


외부 단편화와 압축 작업을 해소하기 위해 생긴 방법론으로 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법이다. 물리 메모리는 Frame이라는 고정 크기로 분리되어 있고, 논리 메모리(프로세스가 점유하는)는 페이지라 불리는 고정 크기의 블록으로 분리된다. 

페이징 기법을 사용함으로써 논리 메모리는 물리 메모리에 저장될 때, 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치됨으로 외부 단편화를 해결할 수 있는 큰 장점이 있다.

* 단점
-내부 단편화 문제의 비중이 늘어나게 된다.
ex)페이지 크기 : 1024B
프로세스 A가 3,172B의 메모리를 요구할 시, 총 4개의 페이지 프레임이 필요하게 되고, 4번 째 페이지 프레임에는 924B의 여유 공간이 남게된다. 
-논리적으로 같은 메모리 영역에 있어야 할 작업들이 나누어지므로 작업을 수행할 때 메모리를 탐색하기 때문에 오버헤드가 발생한다는 단점이 있다. heap, stack,function과 같은 요소가 논리적인 작업에 속한다. 

>페이지 : 프로세스를 일정한 크기로 나눈 블록 (가상 메모리를 사용하는 최소 크기 단위)

>프레임 : 실제 메모리를 사용하는 최소 크기 단위 

>page fault : 요구하는 페이지가 존재하지 않을 때 발생

>page table : 프로세스의 각 페이지가 어느 프레임에 있는지 나타내는 표. 프레임의 기준 주소를 가지고 있다. 하나의 프로세스는 하나의 페이지 테이블을 갖고, 테이블은 인덱스와 내용으로 구성되어 있는데 인덱스는 페이지의 순서를, 내용은 메인 메모리에 들어가는 위치를 가지고 있다. 



![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FclzxqK%2FbtqI25SnzNO%2FKUSIx9jF8Y47v1c21CE7y1%2Fimg.png)

### 3. Segmentation

가상메모리를 서로 크기가 다른 논리적 단위인 Segment로 분할하고 메모리를 할당하여 주소를 변환한다. 

세그먼트들의 크기가 서로 다르기 때문에 물리 메모리를 페이징 기법처럼 미리 분할해 둘 수 없고, 메모리가 적재될 때 빈 공간을 찾아 할당하는 사용자 관점의 가상메모리 관리 기법이다.

페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 세그먼트(Segment)로 분할 사용자가 두 개의 주소로 지정(세그먼트 번호 + 변위) 세그먼트 테이블에는 각 세그먼트의 기준(세그먼트의 시작 물리 주소)과 한계(세그먼트의 길이)를 저장한다. 이 기법은 하나의 세그먼트 단위로 통제가 가능한 장점이 있다. 즉 내부 단편화가 발생하지 않는다. 

하지만 서로 다른 크기의 세그먼트들에 대해 필요할 때 메모리에 올리고 필요없을 경우 내리는 작업을 반복하다보면 외부 단편화가 생기는 문제점이 있다.

>Segmentation Fault : 프로그램이 허용되지 않은 메모리 영역에 접근을 시도하거나, 허용되지 않은 방법으로 메모리 영역에 접근을 시도할 경우 발생한다. 




* 단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들로 나누어져 못 쓰게 될 수도 있다.(외부 단편화)

![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FH4cZs%2FbtqI4eHZcxA%2FEFJxJwHSS8ht4DFc9HxpYK%2Fimg.png)