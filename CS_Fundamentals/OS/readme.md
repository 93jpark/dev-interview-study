
# 컴퓨터 시스템의 구조

### 1. 컴퓨터 시스템의 구조
- 컴퓨터 시스템의 구조는 **컴퓨터 내부장치**인 _CPU_, 메모리와 **컴퓨터 외부장치(I/O)**인 _디스크, 키보드, 마우스, 모니터, 네트워크 장치_ 등으로 구성된다. 
- 컴퓨터는 외부장치에서 내부장치로 데이터를 읽어와 각종 연산을 수행하며 그 결과를 외부장치로 다시 내보내는 방식으로 업무를 처리한다. 

- 메모리 및 입출력장치 등의 각 하드웨어 장치에는 _컨트롤러_ 라는 것이 붙어있다.
컨트롤러는 일종의 **작은 CPU**로서 컴퓨터 전체에 CPU라는 중앙처리장치가 있듯이 컨트롤러는 각 하드웨어 장치마다 존재하면서 이를 제어한다. 
![](https://velog.velcdn.com/images/taeyeeya/post/a89d1781-277c-4e7c-a1b0-c7cadef15e26/image.png)

> ** # Device Controller**
 각각의 디바이스들을 I/O연산, 제어관리를 하는 역할을 한다.(각각의 디바이스들의 CPU 역할)
** # Device Driver**
운영체제가 각각의 디바이스를 접근하게 하기위한 인터페이스역할을하는 소프트웨어.
** # 펌웨어**
디바이스가 동작하기위한 소프트웨어
** # Buffer **
각각의 디바이스 컨트롤러들이 명령을 내려 디바이스의 데이터를 읽어오거나 출력할때는 데이터를 저장하는 공간이다. (각각의 디바이스들의 램역할. 일종의 register)
** # Register **
프로세서에 위치한 고속 메모리로 극히 소량의 데이터나 처리 중인 중간 결과와도 같은 프로세서가 바로 사용할 수 있는 데이터를 담고 있는 영역

### 2. CPU 연산과 I/O 연산
- 컴퓨터에서 연산을 한다는 것은 **CPU가 무언가 일을 한다는 뜻** 이며, 입출력 장치들의 I/O 연산은 입출력 컨트롤러가 담당하고 컴퓨터 내에서 수행되는 연산은 메인 CPU가 담당한다. 이때 입출력장치와 메인 CPU는 동시에 수행이 가능하다.

- 각 장치마다 이를 제어하기 위해 설치된 장치 컨트롤러는 장치로부터 들어오고 나가는 데이터를 임시로 저장하기 위한 작은 메모리를 가지고 있으며 이를 **로컬 버퍼**라고 한다.
- 디스크나 키보드 등에서 데이터를 읽어오는 경우, 우선 로컬버퍼에 데이터가 임시로 저장된 후 메모리에 전달되며 이 때 장치에서 로컬버퍼로 읽어오는 일을 **컨트롤러**가 담당한다. 이때, 로컬 버퍼로 읽어오는 작업이 끝났는지를 메인 CPU가 지속적으로 체크하는 것이 아니라 장치에 있는 컨트롤러가 인터럽터를 발생시켜 CPU에 보고하게 된다.
- **인터럽트**란 _컨트롤러들이 CPU의 서비스가 필요할 때 이를 통보하는 방법_ 을 말하며, 기본적으로 CPU는 매 시점 메모리에 대한 명령(instruction)을 하나씩 읽어와서 수행한다. 이때 CPU 옆에는 인터럽트 라인이 있어서, CPU가 자신의 작업을 하던 중간에 인터럽트 라인에 신호가 들어오면 하던 일을 멈추고 인터럽트와 관련된 일을 먼저 처리한다.
- 인터럽트는 키보드 입력 혹은 요청된 디스크 입출력 작업의 완료 등 CPU에 알려줄 필요가 있는 이벤트가 일어난 경우 컨트롤러가 발생시키는 것이다.
 예를 들어 디스크 컨트롤러가 인터럽트를 발생시키면 CPU는 하던 일을 잠시 멈추고 이 인터럽트가 발생했을 때 수행하도록 정의된 코드를 찾아 수행하며 디스크의 로컬 버퍼에 있는 내용을 사용자 프로그램의 메모리로 전달하고, 해당 프로그램이 CPU를 할당받을 경우 다음 명령을 수행할 수 있음을 표시해둔다.
 

### 3. 인터럽트의 일반적 기능
- 운영체제 커널에는 인터럽트가 들어왔을 때 해야할 일이 미리 다 프로그래밍되어 커널 내에 그 코드가 보관되어 있다. 운영체제는 각종 하드웨어 및 소프트웨어 자원 관리뿐 아니라 사용자 프로그램에 필요한 서비스도 제공한다. 또한 운영체제 커널 내에 있는 인터럽트 처리루틴은 다양한 인터럽트에 대해 각각 처리해야 할 업무들을 정의한다.

- 인터럽트에는 **하드웨어 인터럽트**와 **소프트웨어 인터럽트**가 있다. CPU의 서비스가 필요한 경우, CPU 옆에 있는 인터럽트 라인에 신호를 보내서 인터럽트가 발생했음을 알려주는 방식은 둘 다 동일하다.
하지만 하드웨어 인터럽트는 컨트롤러 등 하드웨어 장치가 CPU의 인터럽트 라인을 세팅하는 반면, 소프트웨어 인터럽트는 소프트웨어가 그 일을 수행한다는 차이점이 있다.
- 인터럽트가 발생하면 CPU는 하던 일을 멈추고 운영체제 커널 내에서 해당 인터럽트의 처리를 위해 정의된 코드를 찾게 되며 운영체제는 할 일을 쉽게 찾아가기 위해 인터럽트 벡터를 가지고 있다. 
- **인터럽트 벡터**란 인터럽트 종류마다 번호를 정해서 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키고 있는 자료구조를 말한다. 실제 처리해야 할 코드는 인터럽트 처리루틴 또는 인터럽트 핸들러라고 불리는 다른 곳에 정의된다.
통상적으로 인터럽트라고 하면 하드웨어 인터럽트를 의미하고, 소프트웨어 인터럽트는 **트랩(trap)**.이라는 용어로 주로 불린다. 소프트웨어 인터럽트의 예로는 예외상황(exception)과 시스템 콜(system call)이 있다.
- **예외상황**이란 사용자 프로그램이 0으로 나누는 연산 등 비정상적인 작업을 시도하거나, 자신의 메모리 영역 바깥에 접근하려는 시도 등 권한이 없는 작업을 시도할 때 이에 대한 처리를 위해 발생시키는 인터럽트를 말한다.
- **시스템콜**이란 사용자 프로그램이 운영체제 내부에 정의된 코드를 실행하고 싶을 때 운영체제에 서비스를 요청하는 방법이다. 사용자 프로그램 자신의 코드는 직접 CPU를 가지고 실행하지만, 
사용자 프로그램에 정의되지 않고 운영체제 커널에 있는 코드를 사용자 프로그램이 실행하고자 할 때에는 인터럽트 라인 세팅을 통해 CPU 제어권을 운영체제로 넘겨 실행하게 되는 것이다.
 

### 4. 인터럽트 핸들링
- **인터럽트 핸들링(interrupt handling)** 이란 인터럽트가 발생한 경우에 처리해야 할 일의 절차를 의미한다.
프로그램 A가 실행되고 있을 때 인터럽트가 발생하면 A의 현재 상태, 즉 현재 CPU에서 실행 중인 명령의 메모리 주소를 포함해 몇 가지 부가적인 정보들을 저장한다. 

- CPU에서 명령이 실행될 때에는 CPU 내부에 있는 임시 기억장치인 **레지스터(register)** 에 데이터를 읽거나 쓰면서 작업을 하는데 이때 인터럽트가 발생해 새로운 명령을 실행하면 기존의 레지스터 값들이 지워지게 되므로 CPU 내의 이러한 상태를 저장해두어야 한다. 이것들을 모두 저장한 후 인터럽트 처리가 이루어질 수 있다.
- 운영체제는 현재 시스템 내에서 실행되는 프로그램을 관리하기 위해 **프로세스 제어블록**(**PCB**;Process Control Block)이라는 자료구조를 둔다. 
**PCB**는 각각의 프로그램마다 하나씩 존재하며 해당 프로그램의 어느 부분이 실행 중이었는지를 정하고 있다. 구체적으로는 프로그램이 실행 중이던 코드의 메모리 주소와 레지스터값, 하드웨어 상태 등이 저장된다.

- 시스템 부팅 후 정상 상태에 머무리면 CPU가 항상 프로그램에 의해 사용되며 인터럽트가 발생할 때에만 운영체제 코드 부분으로 CPU가 이양되어 인터럽트 처리를 수행하게 된다. 
결론적으로 운영체제가 직접 CPU를 점유하는 경우는 인터럽트에 의하지 않고는 발생하지 않는다.

# 운영체제

프로세스와 스레드의 차이점에 대한 질문의 의도 =>
운영체제가 시스템의 자원을 어떤 단위로 할당하고,
프로세스와 스레드는 이 자원을 어떻게 사용하는가?에 대한 질문.

## Process

프로세스는 실행 중인 프로그램으로 디스크로부터 메모리에 적재되어
CPU의 할당을 받을 수 있는것을 말한다.

운영체제로부터 **자원**(주소 공간, 파일, 메모리)**을 할당받는 작업의 단위**를 총칭하여 프로세스라고 한다.

### 프로세스 제어 블록(Process Control Block, PCB)

PCB는 **특정 프로세스에 대한 중요한 정보를 저장**하고 있는 **운영체제의 자료구조**이다.
운영체제는 프로세스를 관리하기 위해 **프로세스의 생성과 동시에 고유한 PCB를 생성**한다.

프로세스는 CPU를 할당받아 작업을 처리하다가 프로세스 전환이 발생하면 진행하던 작업을 저장하고
CPU를 반환해야 하는데, 이때 작업 진행 상황을 모두 PCB로 저장한다.
그리고 CPU를 할당받게 되면 PCB에 저장되어있던 내용을 불러와 이전에 종료됐던 시점부터 다시 시작한다.

## Thread

프로세스가 할당받은 자원을 이용하는 **실행의 단위**이고, 프로세스 내에 여러개 생길 수 있다.
프로세스 내의 주소 공간이나 자원들은 같은 프로세스 내에 스레드끼리 공유한다.

즉 **어플리케이션 하나가 프로세스**이고, 그 안에서 **분기 처리가 스레드**가 되는 셈이다.

하나의 프로세스를 다수의 실행 단위로 구분하여 자원을 공유하고
자원의 생성과 관리의 중복성을 최소화하여 수행 능력을 향상시키는 것을 **멀티스레딩**이라고 한다.

각각의 스레드는 **독립적인 작업을 수행**해야 하기 때문에 **각자의 스택과 PC 레지스터 값**을 갖고 있다.

### 스택을 스레드마다 독립적으로 할당하는 이유

스택은 함수 호출 시 전달되는 인자와 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 **메모리 공간**이다.
그러므로 **스택 메모리 공간이 독립적**이라는 것은 **독립적인 함수 호출이 가능**하다는 뜻이고 곧 **독립적인 실행 흐름이 추가**되는것이다.
따라서 스레드의 정의에 따라 독립적인 실행 흐름을 추가하기 위한 최소 조건으로 독립된 스택을 할당한다.

> 참고자료 - Process, Thread 차이가 뭔가요?
> https://brunch.co.kr/@babosamo/100

> 참고자료 - 프로세스와 스레드의 차이
> https://brunch.co.kr/@kd4/3

## Process Control Block

`프로세스 제어 블록(Process Control Block:PCB)`는 운영체제에서 프로세스에 대한 메타데이터를 저장한 데이터를 말한다. 프로세스가 생성되면 운영체제는 해당 PCB를 생성한다.

프로그램이 실행되면 프로세스가 생성되고 프로세스 주소 값들에 스택, 힙 등의 구조를 기반으로 메모리가 할당된다. 이 떄, 프로세스에 대한 정보들이 PCB에 저장되어 관리된다.

### PCB의 구조

|이름|설명|
|:--:|:--:|
|프로세스 스케줄링 상태 | '준비' '일시중단' 등 프로세스가 CPU에 대한 소유권을 얻은 이후의 상태 |
| 프로세스ID | 프로세스ID, 해당 프로세스의 자식 프로세스ID |
| 프로세스 권한 | 컴퓨터 자원 또는 I/O 장치에 대한 권한 정보 |
| 프로그램 카운터 | 프로세스에서 실행해야 할 다음 명령어의 주소 포인터 |
| CPU레지스터 | 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보 |
| CPU스케쥴링 정보 | CPU 스케쥴러에 의해 중단된 시간 등에 대한 정보 |
| 계정 정보 | 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보 |
| I/O상태 정보 | 프로세스에 할당된 I/O 디바이스 목록 |



<br>

---

<br>


## System Call

`System Call`은 OS가 커널에 접근하기 위한 인터페이스이며 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 사용된다. 유저 프로그램이 I/요청으로 트랩(trap)을 발동하면 올바른 I/O요청인지 확인한 후 유저 모드가 시스템콜을 통해 커널 모드로 변환되어 실행된다. 

<img src="https://github.com/93jpark/dev-interview-study/blob/main/assets/images/os/os_system_call_1.png" width="600" height="300">

fs.readFile()이라는 파일 시스템의 파일을 읽는 함수가 발동 되었다면, 유저 모드에서 파일을 읽지 않고, 커널 모드로 들어가 파일을 읽고 다시 유저 모드로 돌아가 그 뒤에 있는 유저 프로그램의 로직을 수행한다.
> 컴퓨터 자원에 대한 직접 접근을 차단하며 프로그램을 다른 프로그램으로부터 보호할 수 있다.

프로세스나 스레드에서 운영체제로 어떠한 요청을 할 때, `System Call`이라는 인터페이스와 커널을 거쳐 운영체제에 전달된다. 

이 `System Call`은 하나의 추상화 계층으로, 네트워크 통신이나 데이터베이스같은 로우 영역의 처리에 대한 신경을 쓰지 않고 프로그램을 구현할 수 있다는 장점이 있다.


### modebit

<img src="https://github.com/93jpark/dev-interview-study/blob/main/assets/images/os/os_system_call_2.png" width="600" height="300">

`modebit`은 1 또는 0을 가지는 플래그 변수로, 시스템 콜이 작동할 때 *유저 모드*와 *커널 모드*를 구분하기 위해 사용된다. I/O장치(카메라, 키보드 등)은 운영체제를 통해서만 작동해야 한다. 유저 프로그램이 I/O장치를 사용하기 위해서는 시스템 콜을 호출하고 modebit을 변경하여 커널 모드로 변경하여 I/O장치를 이용한 로직을 수행한다. 그 이후, modebitd을 다시 유저모드로 변경하여 로직을 수행한다.


<br>

---

<br>

## Context Switching

<img src="https://github.com/93jpark/dev-interview-study/blob/main/assets/images/os/os_context_switching.png" width="600" height="300">


`Context Switching`은 멀티프로세스 환경에서 CPU가 하나의 프로세스를 실행하던 중 인터럽트로 다음 프로세스가 실행될 때, 실행중이던 기존의 프로세스의 상태에 대한 정보를 저장하고, 다음 프로세스에 대한 정보를 저장하기 위해 레지스터 값(context)를 교체하는 작업을 말한다.

Context Switching시에는 해당 스레드만을 위한 독립된 스택 영역이 생성되고, 나머지 Code Data, Heap은 부모 프로세스 영역에서 공유된다.
프로세스는 레지스터 수, 프로세스에 의해 관리되어야 할 데이터 종류가 많을수록 부담이 커진다. Context Switching의 부하를 줄이기위해서는 저장하고 복원되는 컨텍스트 정보를 줄여야 한다.

> **스레드**는 공유 영역이 많아서 스위칭이 빠르다.
> **프로세스**는 공유 데이터가 적음으로 캐시를 이용해서 상태를 저장한다.

#### Context Switching이 일어나는 상황
- I/O Interrupt
- CPU 사용시간 만료
- 자식 프로세스 Fork
- 인터럽트 처리를 기다릴 때


> Reference
https://applefarm.tistory.com/105
면접을 위한 CS 전공지식 노트 (주홍철 저)


<br>

---

<br>

## Dead Lock

<img src="https://github.com/93jpark/dev-interview-study/blob/main/assets/images/os/os_deadlock.png" width="600" height="300">

`Dead Lock(교착상태)`는 두 개 이상의 프로세스가 서로의 작업이 끝나기만을 기다리고 있어 둘 다 영원히 끝나지 않는 상황을 가리킨다. 운영체제에는 복수의 프로세스, 쓰레드가 수행되면서 동시에 많은 일을 처리한다.

A라는 프로세스가 a라는 자원을 사용하고 있다가 b라는 자원이 필요해서 그 자원을 사용하려는데, B라는 프로세스는 이미 자원 b를 사용중이다. 이 때, 프로세스 B는 a라는 자원을 요구하고 있는 상황이며, 자원a는 이미 프로세스 A가 사용중이다.

이처럼, 서로 다른 프로세스가 상대 프로세스가 점유한 자원을 한 없이 기다리는 상황을 `교착상태`라고 한다.

### 교착상태의 필요조건

- `상호 배제(Mutual Exclusion)` : 한 리소스는 한 번에 한 프로세스만 사용할 수 있다.

- `점유와 대기(Hold and wait)` : 어떤 프로세스가 하나 이상의 리소스를 점유하고 있으면서 다른 프로세스가 사용중인 리소스를 기다리고 있음

- `비선점(No pre-emption)` : 프로세스가 태스크를 마친 후 리소스를 자발적으로 반환할 때까지 기다림

- `환형 대기(Circular wait)` : Hold and wait 관계의 프로세스들이 서로를 기다림



### 교착상태 해결을 위한 방법

- 상호배제 제거 -> 불가
    프린터와 같은 자원은 기본적으로 자원 공유가 불가능하다.

- 점유와 대기의 제거
    프로세스가 시작되기 이전에 해당 프로세스가 필요로 하는 모든 자원을 할당한다.
    - 하지만 이는 기기의 자원 활용성을 저하시킨다. 

- 현재 사용중인 자원을 반환하고, 새로운 자원에 대한 요청을 보낸다.
    - 이는 기아(starvation)으로 이어질 수 있다.

- 비선점의 제거
    - 작업 우선순위가 높은 프로세스에게 자원을 선점하도록 한다.

- 순환 대기의 제거
    - 자원에 숫자를 부여하고, 프로세스는 자원을 요청할 때 자원의 숫자의 오름/내림차순으로 요청한다.

- 교착상태 회피
    `은행원 알고리즘(Banker's Algorithm)`을 이용한다.
    - 총 자원의 양과 현재 할당한 자원의 양을 기준으로 안정(safe)상태와 불안정(unsafe)상태를 구분하고, 안정 상태로 가도록 자원을 할당하는 알고리즘
    - 

<br>



### 교착상태에서 탈출하기 위한 방법

- 프로세스 모두 중지 (all kill)

- 교착 상태의 프로세스가 점유하고 있는 자원을 다른 요구하는 프로세스에게 할당하고, 교착 상태 프로세스를 일시 정지

- 우선 순위가 낮은 프로세스, 수행된 횟수가 적은 프로세스 위주로 자원을 선점하게 해주는 방식
