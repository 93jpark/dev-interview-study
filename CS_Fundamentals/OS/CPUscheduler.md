스케줄러

프로세스들은 자신이 죽을때까지 수많은 큐들을 돌아다니는데 OS가 이 큐 안에 있는 프로세스 중에 하나를 선택하게 하는 원칙을 실행하는 것


 

CPU 스케줄러

다중 프로그램 OS의 기본으로, 여러 프로세스들이 CPU를 교환하며 보다 생산적으로 동작하는데 필요한 스케줄러이다.

CPU를 선점한 프로세스가 대기하는 시간을 줄이고 보다 효율적으로 사용하기 위하여 CPU가 프로세스를 실행하는데 사용되는 시간 비율을 증가시킨다.

기본적으로 다음에 실행될 프로세스를 정하고, 프로세스들을 실행가능한 상태로 만든다.

 운영체제는  CPU 스케줄러(CPU Scheduler)에 의해 Ready Queue(실행 준비가 되어 있는 프로세스들이 대기하는 큐)에 있는 프로세스 중에서 하나를 스케줄링 대상으로 선택해 실행해야 한다.

 

CPU 스케줄러가 필요한 이유

CPU는 한번에 여러 프로세스를 실행시킬 수 없다.

특정 프로세스가 I/O 요청에 의해 대기시간이 발생할 수 있다.

이러한 시간을 생산적으로 활용하고자 CPU를 특정 프로세스로부터 회수해 다른 프로세스에 할당한다. (Context Switching: 다중 프로그램 작성 환경에서 어떤 프로그램의 실현을 중단하고 다른 프로그램의 실행을 재개할 때, 그 프로그램의 재개에 필요한 환경을 다시 설정하는 것.) => CPU 이용률을 최대화

​

스케줄링이 일어나는 시점

- Running(실행) -> Waiting(대기) 

 I/O 발생, 자식프로세스 종료

- Running(실행) -> Terminate(종료)

부모프로세스 종료

-------------------------------------------------> 비선점 프로세스

​

- Running(실행) -> Ready(준비) 

Interrupt 발생

- Waiting(대기) -> Ready(준비)

I/O완료

--------------------------------------------------> 선점 프로세스


 

CPU 스케줄링 알고리즘의 목적

No starvation : 각각의 프로세스들이 오랜시간동안 CPU를 할당받지 못하는 상황이 없도록 한다.

Fairness : 각각의 프로세스에 공평하게 CPU를 할당

Balance : Keeping all parts of the system busy

Batch System [일괄처리 시스템] : 온라인처럼 일에 대한 요청이 발생했을 때, 즉각적으로 처리하는 것이 아닌 일정기간 또는 일정량을 모아뒀다가 한번에 처리하는 방식

Throughput : 시간당 최대의 작업량

Turnaround time : 프로세스의 생성부터 소멸까지의 시간을 최소화

CPU utilization : CPU가 쉬는 시간이 없도록 한다.

Interactive System [대화형 시스템] : 온라인과 같이 일에 대한 요청에 대해 즉각적으로 처리하여 응답을 받을 수 있는 시스템

Response time : 즉각적으로 처리해야하는 시스템이므로 요청에 대해 응답시간을 줄이는 게 중요

Time Sharing System : 각 프로세스에 CPU에 대한 일정시간을 할당하여 주어진 시간동안 프로그램을 수행할 수 있게하는 시스템

Meeting deadlines : 데이터의 손실을 피하며, 끝내야하는 시간 안에 도달해야한다.

Predictability : 멀티미디어 시스템에서의 품질이 저하되는 부분을 방지해야한다.

 

비선점 스케줄링 [Non-preemptive scheduling]

- Time-Slice가 없다.

- CPU를 사용중인 프로세스가 자율적으로 CPU를 반납하는 방식

- 어떤 프로세스가 CPU를 점유하고 있다면 해당 프로세스의 작업이 완료될 때까지 다른 프로세스가 강제로 CPU를 빼앗아 사용할 수 없다.

​

FCFS (First Come First Served)


먼저 CPU를 요청하는 프로세스가 먼저 CPU를 할당받아 처리하는 방식

CPU를 요청하는 프로세스의 burst time(일을 수행하는 시간)에 따라 평균 waiting time이 길어진다.

모든 프로세스의 우선순위가 동일하고, 프로세스의 CPU 처리 시간을 따로 고려하지 않기 때문에 공평하고 가장 단순한 방법이다.

작업 완료 시간을 예측하기 용이하다.

콘보이 효과(실행 시간이 긴 프로세스가 짧은 프로세스보다 앞에 있으면 기다리는 시간이 길어져 효율성이 떨어지는 효과)가 발생할 수 있다.(대화형 시스템에 적절하지  않음)

프로세스가 준비 큐에 진입하면, 프로세스 제어 블록(PCB)을 큐의 끝에 연결한다. CPU가 준비 상태가 되면, 준비 큐의 앞부분에 있는 프로세스에 할당된다. 이 실행 상태의 프로세스는 이어 준비 큐에서 제거된다.



  대기시간  : P1 = 0, P2 = 24, P3 = 27

​

​

선점 스케줄링 [Preemptive scheduling]

- 하나의 프로세스가 CPU를 점유하고 있을 때, 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법

- OS(Operting System, 운영체제)가 스케줄링의 알고리즘에 따라 프로세스에게 CPU를 할당하고, 필요시에는 회수하는 방식

- 높은 우선순위를 가지는 프로세스는 항상 먼저 스케줄되어야 한다.​

​

SRT(Shortest Remaining Time)

SJF 방식을 선점 스케줄링 방식으로 변경한 기법

최단 잔여시간을 우선으로 하는 스케줄링

진행 중인 프로세스가 있어도, 최단 잔여시간인 프로세스를 위해 sleep시키고 짧은 프로세스를 먼저 할당한다.

어떤 알고리즘보다 평균 대기 시간이 가장 짧은 알고리즘

선점형 방식이기 때문에 잦은 Context Switching(재정비)이 일어나고 그에 따른 오버헤드(시스템의 제어 프로그램이 시스템 지원을 위하여 대기하는 시간)가 커진다.

starvation 현상이 더 심각하게 발생할 수 있다.

새로운 프로세스가 도착할 때마다 새로운 스케줄링이 이루어질 수 있다.

변수가 많기 때문에 실행시간을 측정할 수 없어 실제로 사용되기 어렵다.

​

RR(Round Robin)


Time Sharing System을 위해 설계된 스케줄링

FCFS 스케줄링 방식에 선점 스케줄링 방식과 Time Quantum 개념을 추가한 방식

프로세스에게 각각 동일한 CPU 할당 시간(타임 슬라이스, quantum)을 부여해서 그 시간 동안만 CPU를 이용하게 한다.

모든 프로세스가 최초 응답 시간을 빠르게 보장받을 수 있다는 장점

모든 프로세스가 같은 우선순위를 가지기 때문에 어떤 프로세스도 일정시간 이상 기다리지 않는다.

Time slice burst가 일어나면 해당 프로세스는 스케줄링 큐의 끝으로 이동한다.

Time slice 가 심하게 크다면 CPU 처리 시간이 긴 프로세스가 CPU를 오래 점유하며 정작 다른 프로세스들은 이 프로세스의 작업이 끝날 때까지 기다려야 하기 때문에 FCFS와 같은 콘보이효과가 발생하고, Time slice 가 너무 작다면 불필요한 Context Switch가 많이 일어나 overhead가 커진다.

콘보이 효과가 줄어든다. 

각 프로세스는 동일한 크기의 할당시간을 갖기 때문에 CPU 시간이 랜덤한 프로세스들이 섞여있을때 효율적이다.

시간 할당량의 크기는 알고리즘의 성능과 Trade Off(서로 대립되는 요소 사이의 균형)관계임으로 문맥에 적절한 시간 할당량의 크기를 설정해야한다.


 


대기시간 - P1 = 10-4 = 6, P2 = 4, P3 = 7

​

​

선점형+비선점형

데이터가 다수의 프로세스에 의해 공유될 때 racing condition(경쟁상태: 둘 이상의 입력 또는 조작의 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태를 말한다.)이 발생될 수 있다.

mutex(mutual exclusion: 상호배제) lock, monitor 등의 기법을 사용해서 racing condition을 피한다.

Interrupt는 어느 시점에서건 일어날 수 있고, 커널에 의해서 항상 무시될 수는 없기 때문에, Interrupt에 의해서 영향을 받는 코드 부분은 반드시 동시 사용으로부터 보호되어야 한다.

​

SJF (Shortest Job First)


​

모든 방식을 통틀어 평균 waiting time을 최소화하는 방식

burst time이 짧은 프로세스부터 CPU를 할당한다.

 burst time이 긴 프로세스는 오랜 시간 기다려야하므로, 기아(starvation)현상(자신보다 우선순위가 높은 프로세스 때문에 오랫동안 CPU 할당을 받지 못하고 무한정 기다리는 현상)이 발생할 수 있다.

각 프로세스의 CPU 버스트 길이는 알 수 없기 때문에 CPU 스케줄링 수준에서는 구현하기가 어렵다. 따라서 우리는 프로세스별 CPU 버스트의 길이를 예측해서 스케줄링 해야만 한다.

비선점형일 경우 앞의 프로세스가 실행되는 동안 새로운 프로세스가 준비 큐에 도착하면 선택이 발생한다.



 대기시간 - P1 = 3, P2 = 16, P3 = 9, P4 = 0

​

Priority Scheduling (우선 순위 스케줄링)


우선 순위가 높은 프로세스에 CPU를 우선 할당하는 방식의 스케줄링

우선 순위는 시간 제한, 메모리 요구량, 프로세스의 중요성, 자원사용 비용 등에 따라 달라질 수 있다.

우선 순위가 같을 경우, FCFS와 같다. 

- 선점형 스케줄링 방식 (우선순위를 따진다는 것 - 무한 봉쇄(indefinite blocking))

실행 준비는 되어 있으나 CPU를 사용하지 못하는 프로세스는 CPU를 기다리면서 봉쇄 된 것으로 간주할 수 있다. (Blocking)

- 비선점형 스케줄링 방식 (우선순위를 따져서 이미 수행되고 있는것이 자율적으로 CPU를 반납 - 기아 상태(starvation))

부하가 과중한 컴퓨터 시스템에서는 높은 우선순위의 프로세스들이 꾸준히 들어와서 낮은 우선순위의 프로세스들이 CPU를 얻지 못하게 될 수 도 있다. (Starvation)

 

 

참고자료

https://blog.naver.com/PostView.nhn?blogId=anrud7&logNo=221018797089&parentCategoryNo=&categoryNo=70&viewDate=&isShowPopularPosts=true&from=search 

https://imbf.github.io/computer-science(cs)/2020/10/18/CPU-Scheduling.html 

 reference

[OS 공부] CPU 스케줄러 (tistory.com)

[OS 공부] 스케줄러 (tistory.com)

[운영체제] CPU 스케줄러 - FCFS, SJF, SRT, RR, Priority Scheduling (tistory.com)

CPU 스케줄러 전략 (FCFS, SJF, HRN, SRT, Round Robin, Multi-Level Queue) (tistory.com)

OS 정리 4 - CPU 스케줄링 (CPU Scheduling) — HELLO RUNA! (tistory.com)

​

