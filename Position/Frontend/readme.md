# **프론트앤드 면접 질문 정리**

> 참고 자료 : https://github.com/gyoogle/tech-interview-for-developer

> 참고 자료 : https://github.com/junh0328/prepare_frontend_interview

> 참고 자료 : https://github.com/baeharam/Must-Know-About-Frontend

---

# **Frontend**

### **HTTP란?**

HyperText Transfer Protocol의 약자로 데이터를 주고받기 위해 정의한 통신 프로토콜

웹에서 이루어지는 모든 데이터 교환의 기초

웹을 기준으로 브라우저와 서버 간에 데이터를 주고받기 위한 방식으로 HTTP 프로토콜을 사용

#### **GET과 POST의 차이**

HTTP 프로토콜을 이용해서 서버에 무엇인가를 요청할 때 사용하는 방식

**Get** : 데이터가 `HTTP Request Message`의 Header 부분에 url 이 담겨서 전송된다.

때문에 url 상에 `?` 뒤에 데이터가 붙어 request 를 보내게 되는 것이다.

이러한 방식은 url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다.

또 보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 `GET` 방식은 적절하지 않다. (ex. password)

**Post** :  `HTTP Request Message`의 Body 부분에 데이터가 담겨서 전송된다.

때문에 바이너리 데이터를 요청하는 경우 POST 방식으로 보내야 하는 것처럼 데이터 크기가 GET 방식보다 크고 보안면에서 낫다. (하지만 보안적인 측면에서는 암호화를 하지 않는 이상 고만고만.)

GET 은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여준다거나 하는 용도이지 서버의 값이나 상태 등을 변경하지 않는다.

POST 는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용

### **REST API란 무엇인가?**

약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 웹을 위한 네트워크 기반 아키텍처 스타일.

**첫 번째,**

HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고,

**두 번째,**

자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.

**장점**

1. Open API 를 제공하기 쉽다
2. 멀티플랫폼 지원 및 연동이 용이하다.
3. 원하는 타입으로 데이터를 주고 받을 수 있다.
4. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

**단점**

1. 사용할 수 있는 메소드가 4 가지 밖에 없다.
2. 분산환경에는 부적합하다.
3. HTTP 통신 모델에 대해서만 지원한다.

### **브라우저 렌더링 과정**

1. HTML 마크업을 처리하고 DOM 트리를 빌드 (**"무엇을"** 그릴지 결정)
2. CSS 마크업을 처리하고 CSSOM 트리를 빌드 (**"어떻게"** 그릴지 결정)
3. DOM 및 CSSOM 을 결합하여 렌더링 트리를 형성 (**"화면에 그려질 것만"** 결정)
4. 렌더링 트리에서 레이아웃을 실행해 각 노드의 기하학적 형태를 계산 (**"Box-Model"** 을 생성)
5. 개별 노드를 화면에 페인트(or 래스터화)

### **CSSOM이란?**

웹 사이트를 브라우저 상에 표현할 때 서버로부터 받은 정보를 브라우저가 렌더링 엔진을 통해 파싱 하는데 이때 두 가지 요소를 파싱 하는데 하나는 **HTML 과 CSS가 있다.**

이때 HTML을 파싱 하여 자료를 구조화한 것을 **DOM** 이라 하고

CSS 내용을 파싱 하여 자료를 구조화한 것을 **CSSOM** 이라 한다.

**작동원리**

DOM과 같은 트리구조 형태를 띄고 있다.

HTML과 CSS는 결합되어 문서를 나타내기 때문에 CSSOM 또한 DOM처럼 위아래 관계를 가지게 되고 그로 인해 트리구조가 생기는 것이라 볼 수 있다.

### **CORS란?**

다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 **cross-origin HTTP 요청**에 의해 요청된다.

하지만 대부분의 브라우저들은 보안 상의 이유로 스크립트에서의 cross-origin HTTP 요청을 제한한다.

이것을 `Same-Origin-Policy(동일 근원 정책)`이라고 한다.

요청을 보내기 위해서는 요청을 보내고자 하는 대상과 프로토콜도 같아야 하고,

포트도 같아야 함을 의미한다._(이 때, 서브 도메인 네임은 상관없다.)_

### **시멘틱 마크업이란?**

시맨틱(Semantic)이란 "의미론적인"의 뜻을 가지며 마크업(Markup)이란 HTML 태그로 문서를 작성하는 것을 말한다.

따라서, **시맨틱 마크업이란 의미를 잘 전달하도록 문서를 작성하는 것을 말한다.**

### **CSS 박스모델이란?**

CSS 박스 모델은 HTML element가 웹 페이지에서 차지하는 공간을 정의한 모델이다.

각 element는 가운데 실제 element의 내용이 담긴 부분(**content**) / element를 감싸는 경계(**border**) / border와 content 사이의 영역(**padding**) / border 바깥의 영역(**margin**)으로 구성

### **CSR과 SSR이란? 장/단점, 차이점은?**

#### **CSR(Client Side Rendering)**

**렌더링이 클라이언트 쪽에서 일어난다.**

즉, 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내준다.

클라이언트는 그것을 받아 렌더링을 시작한다.

#### **SSR(Server Side Rendering)**

말 그대로 서버쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식이다.

#### **CSR vs SSR 차이**

**1. 웹페이지를 로딩하는 시간**

웹 페이지 로딩의 종류는 두 가지로 나눌 수 있다.

하나는 웹 사이트의 가장 첫 페이지를 로딩하는 것. 다른 하나는 나머지를 로딩하는 것

[**첫 페이지 로딩시간**]

CSR의 경우 HTML, CSS와 모든 스크립트들을 한 번에 불러온다.

반면 SSR은 필요한 부분의 HTML과 스크립트만 불러오게 된다.

따라서 **평균적으로 SSR이 더 빠르다**.

[**나머지 로딩 시간**]

첫 페이지를 로딩한 후, 사이트의 다른 곳으로 이동하는 식의 동작을 가정하자.

CSR은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 빠르다.

반면, SSR은 첫 페이지를 로딩한 과정을 정확하게 다시 실행한다. 그래서 더 느리다.

**2. 서버 자원 사용**

- **SSR이 서버 자원을 더 많이 사용**한다. 매번 서버에 요청을 하기 때문이다.
- 반면 **CSR은 클라이언트에 일감(?)을 몰아주기 때문에 서버에 부하가 적다**.(당연)

### **SPA는 뭔가? 장/단점은?**

**SPA(Single Page Application)** 는 단일 페이지로

기존의 서버 사이드 렌더링과 비교할 때, 배포가 간단하며

**네이티브 앱과 비슷한 사용자 경험**을 제공한다.

SPA는 웹 앱에 **필요한 모든 정적 리소스를 처음에 한번 다운로드**한다.

페이지 간 이동 시, 페이지 갱신에 **필요한 데이터만을 JSON으로 전달받아 페이지를 갱신**하므로

전체적인 트래픽을 감소하고 전체 페이지를 다시 렌더링하지 않고 변경되는 부분만을 갱신하므로

새로고침이 발생하지 않아 **네이티브 앱과 유사한 사용자 경험**을 제공할 수 있다.

이런 특징들은 SPA가 **모바일 웹에 최적화** 된 이유이기도 하다.

**속도, 사용성, 반응성의 향상**으로 더 나은 사용자 경험을 기대할 수 있다.

하지만, **초기 구동속도가 느린 편**이다.

필요한 모든 정적 리소스를 최초에 한번 다운로드하기 때문이다. 또한, **`SEO(검색엔진 최적화)문제`** 가 존재.

SPA는 서버 렌더링 방식이아닌 자바스크립트 기반 비동기 모델(클라이언트 렌더링 방식)이다.

**`SEO(검색 엔진 최적화)`** : 검색자의 의도를 이해하고 이에 맞춰 웹 페이지의 콘텐츠를 제작, 검색 결과 페이지에서 잘 노출 되도록 웹페이지의 태그와 링크 구조를 개선하여 자연 유입 트래픽을 늘림

기존엔 사용자가 다른 페이지로 이동할 때마다 새로운 html을 받아오고, 페이지를 로딩할 때마다 서버에서 리소스를 전달받아 해석하고 보여줬다.

요즘에는 웹에서 제공되는 정보가 정말 많아서 화면을 보여 주어야 할 때마다 서버 측에서 모든 뷰를 준비한다면 성능상 문제가 일어날 수 있다.(트래픽이 너무 많이 나옴, 서버에 높은 부하)

그렇기 때문에 리액트 같은 라이브러리 혹은 프레임워크(뷰)를 사용하여 렌더링을 사용자 브라우저가 담당하도록 하고, 실행시킨 후에 사용자와의 인터랙션이 발생하면 **필요한 부분만 js를 사용하여 업데이트 해준다**.

### **MPA방식**

Link tag를 사용하는 **전통적인 웹 방식**이다.

새로운 페이지 요청 시 마다 정적 리소스가 다운로드 되고 전체 페이지를 다시 렌더링 하므로 **새로고침이 발생**되어 사용성이 좋지 않다.

페이지에서 필요 없는 부분을 포함하여 전체를 갱신하기 때문에 비효율적이다.

하지만, **SEO에 친화적**이다. 네이버나 구글 같은 검색 사이트에 노출되는 것이 중요한 웹사이트라면

MPA 구조로 개발하는 것이 좋다. 또한, 서버에서 이미 렌더링한 결과를 가져오기 때문에

SPA와 달리 첫 로딩이 짧은 편이다.

### **Webpack, Babel, Polyfill이란?**

#### **Webpack이란?**

최신 프런트엔드 프레임워크에서 가장 많이 사용되는 **모듈 번들러(Module Bundler)**입니다.

모듈 번들러란 웹 애플리케이션을 구성하는 자원(HTML, CSS, Javscript, Images 등)을

모두 각각의 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만드는 도구를 의미한다.

#### **Babel이란?**

**트랜스 파일러**(같은 언어이지만 문법적으로 변환해주는 도구)로 ES6+ 버전 이상의 자바스크립트나 JSX

타입스크립트 코드를 하위 버전의 **자바스크립트 코드로 변환 시켜** IE나

다른 브라우저에서 동작할 수 있도록 **결과물을 만들어주는 역할.**

#### **Polyfill이란?**

명세서엔 새로운 문법이나 기존에 없던 내장 함수에 대한 정의가 추가된다.

새로운 문법을 사용해 코드를 작성하면 트랜스파일러는 이를 구 표준을 준수하는 코드로 변경해준다.

반면, 새롭게 표준에 추가된 함수는 명세서 내 정의를 읽고 이에 맞게 직접 함수를 구현해야 사용할 수 있다.

자바스크립트는 매우 동적인 언어라서 원하기만 하면 어떤 함수라도 스크립트에 추가할 수 있다.

즉, 개발자는 스크립트에 새로운 함수를 추가하거나 수정해서 스크립트가 최신 표준을 준수할 수 있게

작업할 수 있고 이렇게 **변경된 표준을 준수할 수 있게 기존 함수의 동작 방식을 수정하거나**

**새롭게 구현한 함수의 스크립트를 "폴리필(polyfill)"이라 부른다.**

폴리필(poly`fill`)은 말 그대로 구현이 누락된 새로운 기능을 메꿔주는(`fill in`) 역할을 합니다.

### **prettier, eslint를 사용해 봤나요?**

오류를 잡으려면 **`eslint` /** 스타일을 교정 하려면 **`prettier`**

#### **eslint**

일관성 있는 방식으로 구현할 수 있도록 잡아주는 것

#### **prettier**

prettier는 eslint처럼 '코드 구현 방식'이 아닌,

줄 바꿈, 공백, 들여 쓰기 등 에디터에서 '텍스트'를 일관되게 작성되도록 도와주는 것

### **Package Manager는 어떤 걸 사용하나요?**

**패키지를 다루는 작업을 편리하고 안전하게 수행하기 위해 사용되는 툴**이다.

여기서 패키지를 다루는 작업이란 `package`를 설치, 업데이트, 수정, 삭제하는 작업을 의미한다.

#### **package**

- 라이브러리가 코드의 묶음이라면, 패키지는 코드의 배표를 위해 사용되는 코드의 묶음
- 라이브러리나 실행 파일을 포함

Node.js의 `NPM` 과 `YARN` 이 있다.

---

# Javascript

### **클로저란 뭔가요?**

클로저는 자신이 선언될 당시의 환경을 기억하는 함수이다.

해당 함수의 생명 주기가 종료되더라도 함수의 반환된 값이 변수에 의해 아직 참조되고 있다면 생명 주기가 종료되더라도, 렉시컬 환경에 남아 참조가 가능하다.

클로저는 **상태(state)를 안전하게 변경하고 유지하기 위해 사용한다.**

상태가 의도치않게 변경되지 않도록 상태를 **안전하게 은닉하고,
특정 함수에게만 상태변경을 허용하기 위해 사용한다.**

### **프로토타입 체인이란 뭔가요?**

#### **프로토타입이란?**

자바스크립트는 프로토타입 기반의 언어이다.
JS의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어있다.
이 부모 객체를 **프로토타입 객체 또는 프로토타입**이라 한다.

#### **프로토타입 체인이란?**

JS는 특정 객체의 프로퍼티나 메소드에 접근시 객체 자신의 것 뿐 아니라 `_proto__` 가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 접근할 수 있다.

즉, 특정 객체의 프로퍼티/메소드 접근시 현재 객체의 해당 프로퍼티가 존재하지 않는다면 `__proto__` 가 가리키는 링크를 따라 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메소드를 차례로 검색하는 것이 프로토타입 체인이다.

### **호이스팅이란 뭔가요?**

JS 엔진은 **변수 선언이 소스코드에 어디있든 상관없이 다른 코드보다 먼저 실행**한다. 런타임 이전에 실행 컨텍스트에 의해 소스코드 평과 가정에서 스코프에 등록되고, 이를 마치 코드의 제일 위에 있는 것처럼 변수가 어디에 위치하던지와 상관없이 **어디서든지 변수를 참조할 수 있는 것처럼 만드는 특징을 변수 호이스팅**이라고 한다.

변수 뿐만 아니라 var, let, const, function, class 키워드를 사용해 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅된다. (**모든 선언문은 런타임 이전 단계에서 먼저 실행되기 떄문이다.**)

### **실행컨텍스트란 뭔가요?**

**실행할 코드에 제공할 환경 정보들을 모아놓은 객체** 및 **실행 컨텍스트는 JS 코드가 실행되는 환경**이다. 모든 JS 코드는 실행 컨텍스트 내부에서 실행된다고 생각하면 된다.

즉 함수가 실행되면 함수 실행에 해당하는 `실행 컨텍스트` 가 생성되고, JS 엔진에 있는 콜 스택에 차곡차곡 쌓인다.
그리고 가장 위에 쌓여있는 컨텍스트와 관련된 코드를 실행하며(LIFO), 전체 코드의 환경과 순서를 보장하게 된다.

실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로, JS의 핵심원리다.

### **비동기와 동기란 뭔가요? 둘의 차이점은?**

#### 동기

말 그대로 동시에 일어난다는 뜻. 요청과 그 결과가 동시에 일어나는 것.

시간이 얼마나 걸리던지 요청한 자리에서 결과가 주어져야 한다.

#### 동기 장단점

설계가 매우 간단하고 직관적 / 결과가 주어질 때 까지 아무것도 못하고 대기해야함

#### 비동기

동시에 일어나지 않는다. 요청한 결과는 동시에 일어나지 않을것

요청한 자리에서 결과가 주어지지 않고, 노드 사이 작업 처리 단위를 동시에 맞추지 않아도 된다.

#### 비동기 장단점

결과가 주어지는데 시간이 걸려도 그 시간동안 다른 작업을 할 수 있음. (자원을 효율적으로 사용함) / 동기보다 복잡

### **콜백 vs Promise vs async await란?**

**비동기적 방식 처리방법**의 3가지 방식이다.

Callback : **다른 함수가 실행을 끝낸 뒤 실행되는 함수(나중에 호출되는 함수)**

코드를 통해 명시적으로 호출이 아닌, 함수를 등록해놓은 후

어떤 이벤트가 발생했거나 특정 시점에 도달했을 때 시스템에서 호출하는 함수를 말한다.

비동기적인 작업을 수행하기 위해 콜백함수를 익명으로 전달하는 과정에서 생기는 콜백 지옥을

**Promise, async/await 등을 사용해 방지**할 수 있다.

Promise : 싱글스레드인 JS에서 비동기 처리를 위해 사용한 Callback 함수의 에**러/예외처리의 어려움, 중첩으로 인한 복잡도 증가(콜백지옥)**라는 단점을 해결하기 위해 프로미스 객체를 ES6에서 언어적 차원으로 지원.

Async / Await : **비동기식 코드를 동기식으로 표현하여 간단하게 나타내는 것**

기존의 비동기 처리 방식인 Callback 함수의 단점을 보완하기 위해 Promise를 사용했는데 코드가 장황하다는 단점이 있어 이걸 해결하기 위해 ES8에서 도입된 **비동기 처리 방식의 가장 최신 문법 (async & await는 Promise 객체를 반환한다. ⇒ then 사용할 수 있다.)**

### **Promise의 3가지 상태는 뭔가요?**

프로미스의 상태란 **프로미스의 처리 과정**을 의미한다.

new Promis()로 프로미스를 생성하고 종료까지 3가지 상태를 갖는다.

- Pending(대기) : 비동기 처리 로직이 아직 완료되지 않은 상태
- Fulfilled(이행) : 비동기 처리가 완료되어 프로미스가 결과 값을 반환해준 상태
- Rejected(실패) : 비동기 처리가 실패하거나 오류가 발생한 상태

완료 상태인 Settled이 있다!

### **async/await 키워드는 무엇을 의미하나요?**

#### async 함수

1. function 앞에 위치한다.
2. function 앞에 async를 붙이면 해당 함수는 항상 프로미스를 반환한다.
3. async가 붙은 함수는 반드시 프로미스를 반환하고, 함수 표현식으로도 정의가 가능

#### await 함수

1. await은 async 함수 안에서만 동작한다.
2. 자바스크립트는 await를 만나면 프로미스가 처리될 떄 까지 기다리고, 그 결과는 이후 반환된다.

async & await **예외처리는** ⇒ **try .. catch{}** 구문 사용!

### **화살표 함수란 뭔가요?**

function 키워드 대신 화살표(⇒)를 사용하여 보다 간략한 방법으로 함수를 선언하는 것. 익명 함수로만 사용할 수 있으며 함수를 호출하기 위해선 함수 표현식을 사용한다.

### **use strict이 뭔가요? 왜 사용하나요?**

‘엄격 모드’라는 뜻이며, 함수 호출에서 제공한대로 값이 정확하게 사용하는것.

#### 사용 이유

안전한 코드를 작성하기 위해, 기존 JS 애매한 문법은 오류를 뱉기 때문에 좀 더 정확한 코드를 작성할 수 있다.

Strict 모드에서는

1. 코드의 문제를 빨리 알리고, 안내하므로 **디버깅이 쉬워지며**

2. JS 엔진의 최적화 처리를 어렵게 만드는 오류를 수정함으로 비 strict 모드의 **동일한 코드보다 빠르게 수행 할 수 있다.**

3. 미래의 ECMAScript로 정의 될 예정 구문을 금지하여 **발생가능한 에러를 예방한다.**

### **자바스크립트가 불안전한 언어라고 하셨는데 왜 그런가요?**

- var가 재할당/재언선
- 컴파일 단계에서 오류를 뿜어내지 않는 등의 이유

> 참고 : `명확한 표준을 가지고 출발한 게 아니라 브라우저 전쟁 과정에서 (IE vs 넷스케이프) 초반에 돈을 보고 많이 성장했어서 이제와서 돌아보면 아쉽게 설계된 부분들이 좀 있는 걸로 알고 있어요
 근데 이걸 불완전하다 라고 표현해도 될지는 잘 모르겠어요 그냥 초반에 아쉽게 설계된 게 하위호환 때문에 어쩔 수 없어진 포인트 아니련지..`

---

# React

### **리액트를 공부한 이유는 뭔가요?**

부분적 컴포넌트 사용이 매력적으로 끌렸다.

재사용성이 좋으면서, 퍼즐을 맞추는것처럼 조립하는 느낌으로 운영되는 방식이 매우 신선했다.

### **리액트에서 상태가 변경될때가 2가지 있는데 어떤 상황에서 변경되나요?**

- 부모 컴포넌트로 받은 props가 바뀔 때
- 자신의 state가 바뀔 떄
- 부모 컴포넌트가 리렌더링 될때

컴포넌트는 state와 부모로부터 전달받은 props 등 다양한 조건에 의해 쉽게 리렌더링이 될 수 있다.

불필요한 리렌더링은 내가 만든 서비스의 성능 저하에 가장 큰 원인이 된다.

이렇게 (값, 함수가 변경될 때)에 맞게 리렌더링이 될 수 있도록 useMemo와 useCallback 함수를 사용한다.

### **useMemo와 useCallback에 대해 아나요?**

useMemo 함수는 메모이제이션된 `값`을 반환한다.

`useMemo(() => fn, [])`

deps에 어떤 변화가 생기면, 내부에 정의된 콜백 함수를 실행하고, **그 함수의 반한 값을 반환한다.**

useCallback 함수는 메모이제이션 된 `함수`를 반환한다.

함수와는 상관없는 상태 값이 변할 때, **함수 컴포넌트에서 불필요하게 함수를 업데이트하는 것을 방지해준다.**

### **메모제이션은 무엇인가요?**

프로그램 실행 시 이전에 계산한 값을 저장하고, **동일한 입력이 들어오면 재활용**하는 방식의 프로그래밍 기법. **(동일한 계산 반복 수행을 제거⇒ 프로그램 실행속도를 빠르게 하는 기술)**

**memoization**을 잘 적용하면 **중복연산을 피할 수 있기 때문에** 메모리를 조금 더 쓰더라도 애플리케이션 성능을 최적화할 수 있다.

### **React.memo란 무엇이고 사용해보셨나요?**

useCallback의 사용만으로 하위 컴포넌트의 리렌더링을 방지할 수 없다.

하위 컴포넌트가 PureComponent 이어야만 불필요한 리렌더링을 막을 수 있다. 컴포넌트를 React.memo()로 래핑하면 해당 컴포넌트는 PureComponent가 된다.

React.memo()로 래핑 될 때, React는 컴포넌트를 렌더링하고 결과를 메모이징한다. 그리고 다음 렌더링이 일어날 때 props가 같으면, React는 메모이징된 내용을 재사용한다.

### **리액트 동시성을 사용해보셨나요?**

`concurrent mode`

순서에 상관없이 동시에 수행될 수 있는것. 즉, 프로그램을 독립적으로 실행될 수 있는 **여러조각으로 나누어 구조화하는 방식**을 의미한다.

자바스크립트 자체는 싱글 스레드라, 리액트에서 동시에 작업을 처리하기 위해 동시성을 사용한다.

동시성은 여러 작업을 작은 단위로 나누고, 그들 간의 우선순위를 정해 그 작업을 번갈아 수행하는 방법이다.

서로 다른 작업들이 실제로 동시에 수행되는건 아니지만, 작업 간의 전환이 매우 빠르게 이루어지면서 동시에 수행되는 것처럼 보이는 것이다.

예시로 게임에 빠져 살던 시절 필자는 컴퓨터를 앞에 두고 밥을 같이 먹은 적이 종종 있었다. 게임에 중요한 상황이 있으면 마우스와 키보드를 잡았다가 게임에 신경 쓰지 않아도 되는 타이밍에 빠르게 밥과 김치를 입에 넣곤 했다. 손이 2개밖에 안 되어 실제로 식사와 게임을 `동시에` 하진 못했지만 작업 간의 전환을 빠르게 하여 동시에 수행하는 듯 보였다.

이렇게 리액트는 동시성 개념을 도입해 싱글 스레드 환경에서 여러 작업을 동시에 할 수 있게 되었다.

### **리액트에서 어떻게 성능최적화를 하나요? 해보셨나요?**

최적화를 하는 방법중에는

1. **state 선언 위치** ⇒ state값이 변경이 되면 그 state가 선언된 컴포넌트와 하위 컴포넌트들이 모두 리렌더링이 된다. 그렇다면 state 선언 위치를 잘 설정해 주는 것만으로 리렌더링 횟수를 줄일 수 있고 최적화가 가능함. 기본적인 선언은 state를 사용할 최상단 컴포넌트에 선언하는 것. ItemList와 Items에서 사용해야할 Item state가 있을때 가장 state선언을 최상단인 ItemLIst에 해야한다. 만약 Index에서 state선언을 하게 된다면 ItemList 뿐만 아닌 Header와 Footer에서 리렌더링이 일어난다.
2. **React.memo()** ⇒ 컴포넌트를 렌더링하여 그 결과를 메모이징 하는데 다음 렌더링이 일어날 때 props가 같으면 메모이징된 내용을 재사용하여 불필요한 리렌더링을 피함.
3. **key값으로 index를 사용하지 않기** ⇒ map()을 돌리는 경우 고유 key값을 부여하는데 index로 키값을 설정하게 된다면 중간에 새로운 값이 삽입된 경우 리마운트가 일어나며 데이터 매칭이 되지 않는 오류가 발생.
4. **useMemo()** ⇒ 컴포넌트 내 함수 값이 리턴이 오래 걸리면 리렌더링 될 때마다 함수가 호출되며 많은 시간이 소요. useMemo는 종속 변수들이 변하지 않으면 함수를 굳이 다시 호출하지 않고 이전에 반환한 참조값을 사용함. 함수 호출 시간도 세이브하고 같은 값을 props로 받는 하위 컴포넌트의 리렌더링도 방지 가능
5. **useCallback** ⇒ hook중 하나로 컴포넌트 내부 로직에서 쓰이는 함수의 재렌더링을 막는다.
   종속성 배열이 빈배열([]):어떤 상태값에도 반응하지 않음
   종속성 배열이 없을 때 : 모든 상태 변화에 반응
   **함수와 종속성 배열을 매개변수로 전달받으면 메모이제이션된 콜백을 반환함.**
   객체 타입이므로 props로 전달될 때 얕은비교가 된다.
   만약 자식 컴포넌트에 전달하는 콜백함수를 inline 함수로 사용하거나, 컴포넌트 내에서 함수를 생성한다면 새로운 함수 참조값을 계속해서 만들고 있고, 메모리가 계쏙 낭비가 되는것!

### **hook이란 무엇인가요?**

16.8버전에 새로 추가된 기능으로 **function components에서 state를 가질 수 있게 된 것.**

**모든것은 하나의 function이 되는것, 함수형 프로그램이이 가능해 진것이다.**(기존에 hook이 나오기 전에는 상태값에 접근, 생명주기 기능을 사용하기 위해 class형 컴포넌트를 선언 해줘야 했음/함수형 컴포넌트는 한번 호출되고 메모리상에서 사라져 상태값 접근과 라이프사이클 구현이 불가능.)

### **커스텀훅을 사용해 봤나요?**

### **HOC란?**

고차 컴포넌트(HOC)란 컴포넌트 로직을 재사용하기 위해 사용되고, 컴포넌트를 가져와 새 컴포넌트를 반환하는 함수입니다.

즉, 컴포넌트를 인자로 받거나 반환하는 함수이다.(다른 컴포넌트를 감싸는 리액트 컴포넌트이다. ⇒ **리액트 컴포넌트를 인자로 받아서, 새로운 리액트 컴포넌트를 리턴하는 함수**)

(Higher-Order Component)라고 많이 불린다!

### **useEffect란 무엇인가요?**

**컴포넌트가 렌더링 될 때 특정 작업을 실행할 수 있도록 하는 훅!**

component가 mount 됐을 때, Unmount, update가 됐을 때, 측정 작업을 처리할 수 있다.

useEffect를 통해 **클래스형 컴포넌트**에서는 **생명주기 메소드를 사용**할 수 있는데, 이를 **함수형 컴포넌트**에서도 사용할 수 있다. ⇒ 즉, **라이프사이클 훅을 대체**할 수 있다.

기본 형태 : useEffect(function, deps)

function : 수행하고자 하는 작업

deps : 배열 형태([])이며, 배열 안에는 검사하고자 하는 특정 값 or 빈 배열

`useEffect(()⇒{console.log(”안녕”)}, []);`

### **useRef의 기능은 무엇인가요?**

useRef는 **current 프로퍼티로 전달된 인자로 초기화된 변경 가능한 ref 객체를 반환**한다. 반환된 객체는 컴포넌트의 전 생애주기를 통해 유지된다.

**저장공간 또는 dom요소에 접근하기 위해 사용되는 리엑트 훅**이다.

Ref reference 즉 참조를 뜻한다.

js를 사용할때 특정 DOM을 사용하기 위해 querySelector 등의 함수를 사용하는데, React를 사용하며 특정 dom을 직접 선택해야 하는 상황이 필요할때 useRef라는 훅을 사용한다.

### **Redux란 무엇인가요? 사용한 이유와 단점은 무엇인가요?**

javascript의 **상태관리 라이브러리**이다. 본질은 **node.js 모듈**

상태란? 데이터이다. 상태는 컴포넌트 내부에서 사용하는 데이터를 말한다.

프로젝트 규모가 커지면서 컴퍼넌트 갯수도 많아지고 그에 따라 관리하는 state들이 많아지며 그 안에서 사용되는 상태값(state)들도 복잡해지기 마련이다. 그래서 상태 관리 라이브러리를 사용하는데 그 중에 하나가 Redux!

Redux는 컴포넌트의 상태 업데이트 관련 로직을 다른 파일로 분리시켜서 더욱 효율적으로 관리한다.

또한 컴포넌트끼리 똑같은 상태를 공유해야 할 때도 여러 컴포넌트를 거치지 않고 손쉽게 상태 값을 전달하거나 업데이트 한다.

전역 상태를 관리할때 효율적이며, 체계적으로 상태를 관리할 수 있고, 프로젝트 규모가 클 경우 리덕스를 사용하는것이 좋다. (코드의 유지보수성, 작업 효율 극대화), 또한 **미들웨어라는** 기능을 제공하여 **비동기 작업을 훨씬 효율적으로 관리**

### **MobX나 Recoil등을 사용해 본적이 있나요?**

React 에서의 데이터 흐름은 단방향이기 때문에, 컴포넌트가 관리하는 데이터를 `부모 컴포넌트`에서 `자식 컴포넌트`에게 전달하는 것은 가능하지만, `자식 컴포넌트`=> `부모 컴포넌트` 또는 `자식 컴포넌트` => `자식 컴포넌트`방식으로 전달하는 것은 불가능하다. 위와 같은 방식으로 상태 및 데이터를 전달할 때, 자식 컴포넌트의 depth가 커질 경우 상태 관리가 복잡해질 수밖에 없으며, `props drilling`과 같은 이슈가 생긴다.

이러한 이슈를 해결하기 위해 등장한 것이 상태 관리 툴이며, 아래 목록은 대표적으로 사용되는 툴 예시가 1. Redux, 2. Mobx, 3. Recoil이 있다.

[참고자료](https://velog.io/@kskim625/React-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC-Redux-Mobx-Recoil)

### **Styled-components 관련 질문**

Css in JS로 js안에 css를 작성하는것을 의미한다. styeld-components는 현존하는 css in js 관련 리액트 라이브러리 중에서 가장 인기있다.

이에 대안으로는 emotion과 styled-jsx가 있다.

기존 돔을 만드는 방식으로 css, scss 파일을 밖에 두고, 태그나 id, class 이름으로 가져와 쓰지 않고, 동일한 컴포넌트 이름을 쓰듯 스타일을 지정하는 것을 styled-components라고 부른다.

css 파일을 밖에 두지 않고, 컴포넌트 내부에 넣기 때문에 css가 전역으로 중첩되지 않도록 만들어주는 장점이 있다.
