# **프론트앤드 면접 질문 정리**

> 참고 자료 : https://github.com/gyoogle/tech-interview-for-developer

> 참고 자료 : https://github.com/junh0328/prepare_frontend_interview

> 참고 자료 : https://github.com/baeharam/Must-Know-About-Frontend

---

# **Frontend**

### **HTTP란?**

HyperText Transfer Protocol의 약자로 데이터를 주고받기 위해 정의한 통신 프로토콜

웹에서 이루어지는 모든 데이터 교환의 기초

웹을 기준으로 브라우저와 서버 간에 데이터를 주고받기 위한 방식으로 HTTP 프로토콜을 사용

#### **GET과 POST의 차이**

HTTP 프로토콜을 이용해서 서버에 무엇인가를 요청할 때 사용하는 방식

**Get** : 데이터가 `HTTP Request Message`의 Header 부분에 url 이 담겨서 전송된다.

때문에 url 상에 `?` 뒤에 데이터가 붙어 request 를 보내게 되는 것이다.

이러한 방식은 url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다.

또 보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 `GET` 방식은 적절하지 않다. (ex. password)

**Post** :  `HTTP Request Message`의 Body 부분에 데이터가 담겨서 전송된다.

때문에 바이너리 데이터를 요청하는 경우 POST 방식으로 보내야 하는 것처럼 데이터 크기가 GET 방식보다 크고 보안면에서 낫다. (하지만 보안적인 측면에서는 암호화를 하지 않는 이상 고만고만.)

GET 은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여준다거나 하는 용도이지 서버의 값이나 상태 등을 변경하지 않는다.

POST 는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용

### **REST API란 무엇인가?**

약자로 자원을 이름으로 구분하여 해당 자원의 상태를 주고받는 웹을 위한 네트워크 기반 아키텍처 스타일.

**첫 번째,**

HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고,

**두 번째,**

자원에 대한 행위는 HTTP Method(GET, POST, PUT, DELETE)로 표현한다.

**장점**

1. Open API 를 제공하기 쉽다
2. 멀티플랫폼 지원 및 연동이 용이하다.
3. 원하는 타입으로 데이터를 주고 받을 수 있다.
4. 기존 웹 인프라(HTTP)를 그대로 사용할 수 있다.

**단점**

1. 사용할 수 있는 메소드가 4 가지 밖에 없다.
2. 분산환경에는 부적합하다.
3. HTTP 통신 모델에 대해서만 지원한다.

### **브라우저 렌더링 과정**

1. HTML 마크업을 처리하고 DOM 트리를 빌드 (**"무엇을"** 그릴지 결정)
2. CSS 마크업을 처리하고 CSSOM 트리를 빌드 (**"어떻게"** 그릴지 결정)
3. DOM 및 CSSOM 을 결합하여 렌더링 트리를 형성 (**"화면에 그려질 것만"** 결정)
4. 렌더링 트리에서 레이아웃을 실행해 각 노드의 기하학적 형태를 계산 (**"Box-Model"** 을 생성)
5. 개별 노드를 화면에 페인트(or 래스터화)

### **CSSOM이란?**

웹 사이트를 브라우저 상에 표현할 때 서버로부터 받은 정보를 브라우저가 렌더링 엔진을 통해 파싱 하는데 이때 두 가지 요소를 파싱 하는데 하나는 **HTML 과 CSS가 있다.**

이때 HTML을 파싱 하여 자료를 구조화한 것을 **DOM** 이라 하고

CSS 내용을 파싱 하여 자료를 구조화한 것을 **CSSOM** 이라 한다.

**작동원리**

DOM과 같은 트리구조 형태를 띄고 있다.

HTML과 CSS는 결합되어 문서를 나타내기 때문에 CSSOM 또한 DOM처럼 위아래 관계를 가지게 되고 그로 인해 트리구조가 생기는 것이라 볼 수 있다.

### **CORS란?**

다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 **cross-origin HTTP 요청**에 의해 요청된다.

하지만 대부분의 브라우저들은 보안 상의 이유로 스크립트에서의 cross-origin HTTP 요청을 제한한다.

이것을 `Same-Origin-Policy(동일 근원 정책)`이라고 한다.

요청을 보내기 위해서는 요청을 보내고자 하는 대상과 프로토콜도 같아야 하고,

포트도 같아야 함을 의미한다._(이 때, 서브 도메인 네임은 상관없다.)_

### **시멘틱 마크업이란?**

시맨틱(Semantic)이란 "의미론적인"의 뜻을 가지며 마크업(Markup)이란 HTML 태그로 문서를 작성하는 것을 말한다.

따라서, **시맨틱 마크업이란 의미를 잘 전달하도록 문서를 작성하는 것을 말한다.**

### **CSS 박스모델이란?**

CSS 박스 모델은 HTML element가 웹 페이지에서 차지하는 공간을 정의한 모델이다.

각 element는 가운데 실제 element의 내용이 담긴 부분(**content**) / element를 감싸는 경계(**border**) / border와 content 사이의 영역(**padding**) / border 바깥의 영역(**margin**)으로 구성

### **CSR과 SSR이란? 장/단점, 차이점은?**

#### **CSR(Client Side Rendering)**

**렌더링이 클라이언트 쪽에서 일어난다.**

즉, 서버는 요청을 받으면 클라이언트에 HTML과 JS를 보내준다.

클라이언트는 그것을 받아 렌더링을 시작한다.

#### **SSR(Server Side Rendering)**

말 그대로 서버쪽에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식이다.

#### **CSR vs SSR 차이**

**1. 웹페이지를 로딩하는 시간**

웹 페이지 로딩의 종류는 두 가지로 나눌 수 있다.

하나는 웹 사이트의 가장 첫 페이지를 로딩하는 것. 다른 하나는 나머지를 로딩하는 것

[**첫 페이지 로딩시간**]

CSR의 경우 HTML, CSS와 모든 스크립트들을 한 번에 불러온다.

반면 SSR은 필요한 부분의 HTML과 스크립트만 불러오게 된다.

따라서 **평균적으로 SSR이 더 빠르다**.

[**나머지 로딩 시간**]

첫 페이지를 로딩한 후, 사이트의 다른 곳으로 이동하는 식의 동작을 가정하자.

CSR은 이미 첫 페이지 로딩할 때 나머지 부분을 구성하는 코드를 받아왔기 때문에 빠르다.

반면, SSR은 첫 페이지를 로딩한 과정을 정확하게 다시 실행한다. 그래서 더 느리다.

**2. 서버 자원 사용**

- **SSR이 서버 자원을 더 많이 사용**한다. 매번 서버에 요청을 하기 때문이다.
- 반면 **CSR은 클라이언트에 일감(?)을 몰아주기 때문에 서버에 부하가 적다**.(당연)

### **SPA는 뭔가? 장/단점은?**

**SPA(Single Page Application)** 는 단일 페이지로

기존의 서버 사이드 렌더링과 비교할 때, 배포가 간단하며

**네이티브 앱과 비슷한 사용자 경험**을 제공한다.

SPA는 웹 앱에 **필요한 모든 정적 리소스를 처음에 한번 다운로드**한다.

페이지 간 이동 시, 페이지 갱신에 **필요한 데이터만을 JSON으로 전달받아 페이지를 갱신**하므로

전체적인 트래픽을 감소하고 전체 페이지를 다시 렌더링하지 않고 변경되는 부분만을 갱신하므로

새로고침이 발생하지 않아 **네이티브 앱과 유사한 사용자 경험**을 제공할 수 있다.

이런 특징들은 SPA가 **모바일 웹에 최적화** 된 이유이기도 하다.

**속도, 사용성, 반응성의 향상**으로 더 나은 사용자 경험을 기대할 수 있다.

하지만, **초기 구동속도가 느린 편**이다.

필요한 모든 정적 리소스를 최초에 한번 다운로드하기 때문이다. 또한, **`SEO(검색엔진 최적화)문제`** 가 존재.

SPA는 서버 렌더링 방식이아닌 자바스크립트 기반 비동기 모델(클라이언트 렌더링 방식)이다.

**`SEO(검색 엔진 최적화)`** : 검색자의 의도를 이해하고 이에 맞춰 웹 페이지의 콘텐츠를 제작, 검색 결과 페이지에서 잘 노출 되도록 웹페이지의 태그와 링크 구조를 개선하여 자연 유입 트래픽을 늘림

기존엔 사용자가 다른 페이지로 이동할 때마다 새로운 html을 받아오고, 페이지를 로딩할 때마다 서버에서 리소스를 전달받아 해석하고 보여줬다.

요즘에는 웹에서 제공되는 정보가 정말 많아서 화면을 보여 주어야 할 때마다 서버 측에서 모든 뷰를 준비한다면 성능상 문제가 일어날 수 있다.(트래픽이 너무 많이 나옴, 서버에 높은 부하)

그렇기 때문에 리액트 같은 라이브러리 혹은 프레임워크(뷰)를 사용하여 렌더링을 사용자 브라우저가 담당하도록 하고, 실행시킨 후에 사용자와의 인터랙션이 발생하면 **필요한 부분만 js를 사용하여 업데이트 해준다**.

### **MPA방식**

Link tag를 사용하는 **전통적인 웹 방식**이다.

새로운 페이지 요청 시 마다 정적 리소스가 다운로드 되고 전체 페이지를 다시 렌더링 하므로 **새로고침이 발생**되어 사용성이 좋지 않다.

페이지에서 필요 없는 부분을 포함하여 전체를 갱신하기 때문에 비효율적이다.

하지만, **SEO에 친화적**이다. 네이버나 구글 같은 검색 사이트에 노출되는 것이 중요한 웹사이트라면

MPA 구조로 개발하는 것이 좋다. 또한, 서버에서 이미 렌더링한 결과를 가져오기 때문에

SPA와 달리 첫 로딩이 짧은 편이다.

### **Webpack, Babel, Polyfill이란?**

#### **Webpack이란?**

최신 프런트엔드 프레임워크에서 가장 많이 사용되는 **모듈 번들러(Module Bundler)**입니다.

모듈 번들러란 웹 애플리케이션을 구성하는 자원(HTML, CSS, Javscript, Images 등)을

모두 각각의 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만드는 도구를 의미한다.

#### **Babel이란?**

**트랜스 파일러**(같은 언어이지만 문법적으로 변환해주는 도구)로 ES6+ 버전 이상의 자바스크립트나 JSX

타입스크립트 코드를 하위 버전의 **자바스크립트 코드로 변환 시켜** IE나

다른 브라우저에서 동작할 수 있도록 **결과물을 만들어주는 역할.**

#### **Polyfill이란?**

명세서엔 새로운 문법이나 기존에 없던 내장 함수에 대한 정의가 추가된다.

새로운 문법을 사용해 코드를 작성하면 트랜스파일러는 이를 구 표준을 준수하는 코드로 변경해준다.

반면, 새롭게 표준에 추가된 함수는 명세서 내 정의를 읽고 이에 맞게 직접 함수를 구현해야 사용할 수 있다.

자바스크립트는 매우 동적인 언어라서 원하기만 하면 어떤 함수라도 스크립트에 추가할 수 있다.

즉, 개발자는 스크립트에 새로운 함수를 추가하거나 수정해서 스크립트가 최신 표준을 준수할 수 있게

작업할 수 있고 이렇게 **변경된 표준을 준수할 수 있게 기존 함수의 동작 방식을 수정하거나**

**새롭게 구현한 함수의 스크립트를 "폴리필(polyfill)"이라 부른다.**

폴리필(poly`fill`)은 말 그대로 구현이 누락된 새로운 기능을 메꿔주는(`fill in`) 역할을 합니다.

### **prettier, eslint를 사용해 봤나요?**

오류를 잡으려면 **`eslint` /** 스타일을 교정 하려면 **`prettier`**

#### **eslint**

일관성 있는 방식으로 구현할 수 있도록 잡아주는 것

#### **prettier**

prettier는 eslint처럼 '코드 구현 방식'이 아닌,

줄 바꿈, 공백, 들여 쓰기 등 에디터에서 '텍스트'를 일관되게 작성되도록 도와주는 것

### **Package Manager는 어떤 걸 사용하나요?**

**패키지를 다루는 작업을 편리하고 안전하게 수행하기 위해 사용되는 툴**이다.

여기서 패키지를 다루는 작업이란 `package`를 설치, 업데이트, 수정, 삭제하는 작업을 의미한다.

#### **package**

- 라이브러리가 코드의 묶음이라면, 패키지는 코드의 배표를 위해 사용되는 코드의 묶음
- 라이브러리나 실행 파일을 포함

Node.js의 `NPM` 과 `YARN` 이 있다.

---

# Javascript

- **클로저란 뭔가요?**

- **프로토타입 체인이란 뭔가요?**

- **호이스팅이란 뭔가요?**

- **실행컨텍스트란 뭔가요?**

- **비동기와 동기란 뭔가요? 둘의 차이점은?**

- **콜백 vs Promise vs async await란?**

  - **Promise의 3가지 상태는 뭔가요?**

  - **await 키워드는 무엇을 의미하나요?**

- **화살표 함수란 뭔가요?**

- **use strict이 뭔가요? 왜 사용하나요?**

- **자바스크립트가 불안전한 언어라고 하셨는데 왜 그런가요?**
  (**나는 var가 재할당/재언선 되거나 컴파일 단계에서 오류를 뿜어내지 않는 등의 이유로 설명을 드렸고 납득하신 것 같았다.)**

- **타입스크립트를 사용해봤나요?**

---

# React

- **리액트를 공부한 이유는 뭔가요?**

- **리액트에서 상태가 변경될때가 2가지 있는데 어떤 상황에서 변경되나요?**
- **useMemo와 useCallback에 대해 아나요?**

- **메모제이션은 무엇인가요?**

- **React.memo란 무엇이고 사용해보셨나요?**

- **리액트 동시성을 사용해보셨나요?**

- **리액트에서 어떻게 성능최적화를 하나요? 해보셨나요?**

- **hook이란 무엇인가요?**

- **커스텀훅을 사용해 봤나요?**

- **HOC란?**

- **useEffect란 무엇인가요?**

- **useRef의 기능은 무엇인가요?**

- **Redux란 무엇인가요? 사용한 이유와 단점은 무엇인가요?**

  - **왜 리덕스를 사용했나요?**
  - **Redux-saga의 메서드 관련 질문**

  - **Redux-persist 쓴 이유**

  - **MobX나 Recoil등을 사용해 본적이 있나요?**

- **Styled-components 관련 질문**
